<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>AI Remediation Report</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f3f4f6;
    --panel: #ffffff;
    --panel-soft: #f9fafb;
    --border: #e5e7eb;
    --text-main: #111827;
    --text-muted: #6b7280;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    padding: 24px 12px 32px;
    font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background:
      radial-gradient(circle at top left, rgba(59,130,246,0.13), transparent 55%),
      radial-gradient(circle at top right, rgba(244,114,182,0.13), transparent 55%),
      var(--bg);
    color: var(--text-main);
    overflow-x: hidden;
  }
  .container {
    max-width: 1180px;
    margin: 0 auto;
  }
  .shell {
    background: linear-gradient(to bottom, rgba(255,255,255,0.88), #ffffff);
    border-radius: 26px;
    padding: 20px 22px 26px;
    box-shadow:
      0 26px 60px rgba(15,23,42,0.20),
      0 0 0 1px rgba(209,213,219,0.8);
  }

  h1 {
    margin: 0 0 6px;
    font-size: 26px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    background: linear-gradient(90deg, #0ea5e9, #6366f1, #a855f7);
    -webkit-background-clip: text;
    color: transparent;
  }

  .meta-row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 18px;
  }
  .chip {
    border-radius: 999px;
    padding: 3px 10px;
    font-size: 11px;
    background: var(--panel-soft);
    border: 1px solid #e5e7eb;
    color: #374151;
  }
  .chip span {
    font-weight: 600;
  }

  /* Filter bar */
  .filter-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    margin: 6px 0 16px;
    flex-wrap: wrap;
  }
  .filter-bar-label {
    font-size: 12px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.12em;
  }
  .filter-btn {
    border-radius: 999px;
    border: 1px solid #e5e7eb;
    background: #f9fafb;
    padding: 4px 10px;
    font-size: 12px;
    cursor: pointer;
    color: #374151;
  }
  .filter-btn.active {
    background: #eef2ff;
    border-color: #6366f1;
    color: #4338ca;
    font-weight: 600;
  }

  .summary-grid {
    display: grid;
    grid-template-columns: minmax(0,1.4fr) minmax(0,1.1fr) minmax(0,1.1fr);
    gap: 16px;
    margin-bottom: 18px;
  }
  .summary-block {
    background: var(--panel-soft);
    border-radius: 18px;
    padding: 14px 15px 14px;
    border: 1px solid #e5e7eb;
    box-shadow: 0 10px 25px rgba(15,23,42,0.06);
  }
  .summary-block h2 {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: #6b7280;
    margin: 0 0 6px;
  }
  .summary-block p {
    margin: 0;
    font-size: 13px;
    color: #111827;
  }

  .pie-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .pie {
    width: 80px;
    height: 80px;
    border-radius: 999px;
    box-shadow:
      0 0 0 1px rgba(209,213,219,0.9),
      0 14px 28px rgba(15,23,42,0.12);
  }
  .legend {
    list-style: none;
    padding: 0;
    margin: 0;
    font-size: 12px;
    color: #374151;
  }
  .legend li {
    display: flex;
    align-items: center;
    margin-bottom: 2px;
  }
  .legend-swatch {
    width: 10px;
    height: 10px;
    border-radius: 3px;
    margin-right: 6px;
  }

  /* Timeline layout (FIXED: khÃ´ng bá»‹ bÃ³ card) */
  .timeline {
    margin-top: 8px;
  }
  .timeline-item {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    margin-bottom: 12px;
  }
  .timeline-rail {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 18px;
    flex-shrink: 0;
  }
  .timeline-dot {
    width: 10px;
    height: 10px;
    border-radius: 999px;
    margin-top: 6px;
    box-shadow: 0 0 0 3px #f3f4f6;
  }
  .timeline-line {
    flex: 1;
    width: 2px;
    margin-top: 4px;
    background: linear-gradient(to bottom, rgba(156,163,175,0.9), rgba(209,213,219,0.0));
  }

  .timeline-dot.sev-critical { background: #ef4444; }
  .timeline-dot.sev-high { background: #f97316; }
  .timeline-dot.sev-medium,
  .timeline-dot.sev-moderate { background: #facc15; }
  .timeline-dot.sev-low { background: #22c55e; }
  .timeline-dot.sev-warning { background: #fbbf24; }
  .timeline-dot.sev-error { background: #b91c1c; }
  .timeline-dot.sev-info { background: #0ea5e9; }
  .timeline-dot.sev-unknown { background: #9ca3af; }

  .finding-card {
    background: #ffffff;
    border-radius: 18px;
    padding: 12px 14px 12px;
    border: 1px solid var(--border);
    box-shadow:
      0 14px 32px rgba(15,23,42,0.09);
    flex: 1;
    min-width: 0;
  }

  .finding-header {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 8px;
  }
  .id-tag {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 999px;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    color: #374151;
  }
  .tool-badge {
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    background: #eef2ff;
    border: 1px solid #e0e7ff;
    color: #4338ca;
  }
  .sev-pill {
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .sev-critical { background: #fee2e2; color: #b91c1c; }
  .sev-high { background: #ffedd5; color: #b45309; }
  .sev-medium, .sev-moderate { background: #fef9c3; color: #92400e; }
  .sev-low { background: #ecfdf3; color: #15803d; }
  .sev-warning { background: #fffbeb; color: #92400e; }
  .sev-error { background: #fee2e2; color: #b91c1c; }
  .sev-info { background: #e0f2fe; color: #0369a1; }
  .sev-unknown { background: #e5e7eb; color: #4b5563; }

  .location {
    font-size: 12px;
    color: var(--text-muted);
  }
  .location code {
    font-size: 12px;
  }

  .finding-main {
    display: grid;
    grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.3fr);
    gap: 12px;
    margin-bottom: 8px;
  }
  .label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: var(--text-muted);
    margin-bottom: 2px;
  }
  .text {
    font-size: 13px;
    color: var(--text-main);
    word-wrap: break-word;
  }

  .finding-ai {
    margin-top: 4px;
  }
  .ai-pre {
    margin: 0;
    background: #020617;
    color: #e5e7eb;
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12px;
    max-height: 260px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .ai-pre code {
    color: inherit;
  }

  .ctx-details {
    margin-top: 6px;
    font-size: 12px;
  }
  .ctx-details summary {
    cursor: pointer;
    color: #2563eb;
  }
  .ctx-pre {
    margin-top: 4px;
    max-height: 200px;
    overflow-y: auto;
    background: #0f172a;
    color: #e5e7eb;
    border-radius: 8px;
    padding: 6px 8px;
    font-size: 12px;
  }
  .ctx-pre code {
    color: inherit;
  }
</style>
</head>
<body>
  <div class="container">
    <div class="shell">
      <header>
        <h1>AI Remediation Report</h1>
        <div class="meta-row">
          <span>Generated at <code>2025-12-12T14:52:55.107550+00:00</code></span>
          <span class="chip"><span>389</span> findings</span>
          <span class="chip">By severity: high: 159, low: 134, medium: 55, warning: 21, critical: 12, error: 7, info: 1</span>
        </div>
      </header>

      <div class="filter-bar">
        <span class="filter-bar-label">Filter by tool</span>
        <button class="filter-btn active" data-filter-tool="all">All</button>
        <button class="filter-btn" data-filter-tool="semgrep">Semgrep</button>
        <button class="filter-btn" data-filter-tool="trivy">Trivy</button>
        <button class="filter-btn" data-filter-tool="snyk">Snyk</button>
      </div>

      <section class="summary-grid">
        <div class="summary-block">
          <h2>Overview</h2>
          <p>Use this dashboard to review vulnerabilities detected by Semgrep, Trivy, and Snyk, together with AI-generated remediation suggestions tailored to each finding.</p>
        </div>
        <div class="summary-block">
          <h2>Severity Distribution</h2>
          <div class="pie-row">
            <div class="pie" style="background: conic-gradient(#ef4444 0.00% 3.08%, #f97316 3.08% 43.96%, #facc15 43.96% 58.10%, #22c55e 58.10% 92.54%, #0ea5e9 92.54% 92.80%, #fbbf24 92.80% 98.20%, #b91c1c 98.20% 100.00%);"></div>
            <ul class="legend">
              <li><span class="legend-swatch" style="background:#ef4444"></span>critical: 12</li><li><span class="legend-swatch" style="background:#f97316"></span>high: 159</li><li><span class="legend-swatch" style="background:#facc15"></span>medium: 55</li><li><span class="legend-swatch" style="background:#22c55e"></span>low: 134</li><li><span class="legend-swatch" style="background:#0ea5e9"></span>info: 1</li><li><span class="legend-swatch" style="background:#fbbf24"></span>warning: 21</li><li><span class="legend-swatch" style="background:#b91c1c"></span>error: 7</li>
            </ul>
          </div>
        </div>
        <div class="summary-block">
          <h2>Tools Coverage</h2>
          <div class="pie-row">
            <div class="pie" style="background: conic-gradient(#6366f1 0.00% 14.91%, #8b5cf6 14.91% 92.54%, #06b6d4 92.54% 100.00%);"></div>
            <ul class="legend">
              <li><span class="legend-swatch" style="background:#6366f1"></span>TRIVY: 58</li><li><span class="legend-swatch" style="background:#8b5cf6"></span>SNYK: 302</li><li><span class="legend-swatch" style="background:#06b6d4"></span>SEMGREP: 29</li>
            </ul>
          </div>
        </div>
      </section>

      <section class="timeline">
        
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#1</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">zlib: heap-based buffer over-read and overflow in inflate() in inflate.c via a large gzip header extra field</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">zlib through 1.2.12 has a heap-based buffer over-read or buffer overflow in inflate in inflate.c via a large gzip header extra field. NOTE: only applications that call inflateGetHeader are affected. Some common applications bundle the affected zlib source code but may be unable to call inflateGetHeader (e.g., see the nodejs/node reference).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#2</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">bson: Deserialization of Untrusted Data could result in Code injection or Excessive CPU load</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">All versions of bson before 1.1.4 are vulnerable to Deserialization of Untrusted Data. The package will ignore an unknown value for an object&#x27;s _bsotype, leading to cases where an object is serialized as a document rather than the intended BSON type.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#3</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">form-data: Unsafe random function in form-data</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Use of Insufficiently Random Values vulnerability in form-data allows HTTP Parameter Pollution (HPP). This vulnerability is associated with program files lib/form_data.Js.

This issue affects form-data: &lt; 2.5.4, 3.0.0 - 3.0.3, 4.0.0 - 4.0.3.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#4</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">minimist: prototype pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Minimist &lt;=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#5</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">minimist: prototype pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Minimist &lt;=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#6</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">minimist: prototype pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Minimist &lt;=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#7</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">minimist: prototype pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Minimist &lt;=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#8</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">minimist: prototype pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Minimist &lt;=1.2.5 is vulnerable to Prototype Pollution via file index.js, function setKey() (lines 69-95).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#9</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-mixin-deep: prototype pollution in function mixin-deep</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">mixin-deep is vulnerable to Prototype Pollution in versions before 1.3.2 and version 2.0.0. The function mixin-deep could be tricked into adding or modifying properties of Object.prototype using a constructor payload.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#10</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-set-value: prototype pollution in function set-value</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">set-value is vulnerable to Prototype Pollution in versions lower than 3.0.1. The function mixin-deep could be tricked into adding or modifying properties of Object.prototype using any of the constructor, prototype and _proto_ payloads.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#11</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-set-value: prototype pollution in function set-value</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">set-value is vulnerable to Prototype Pollution in versions lower than 3.0.1. The function mixin-deep could be tricked into adding or modifying properties of Object.prototype using any of the constructor, prototype and _proto_ payloads.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-critical"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#12</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-critical">critical</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-underscore: Arbitrary code execution via the template function</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The package underscore from 1.13.0-0 and before 1.13.0-2, from 1.3.2 and before 1.12.1 are vulnerable to Arbitrary Code Injection via the template function, particularly when a variable property is passed as an argument as it is not sanitized.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#13</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Asymmetric Resource Consumption (Amplification)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Asymmetric Resource Consumption (Amplification) via the `extendedparser` and `urlencoded` functions when the URL encoding process is enabled. An attacker can flood the server with a large number of specially crafted requests.
## Remediation
Upgrade `body-parser` to version 1.20.3 or higher.
## References
- [GitHub Commit](https://github.com/expressjs/body-parser/commit/b2695c4450f06ba3b0ccf48d872a229bb41c9bce)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#14</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Asymmetric Resource Consumption (Amplification)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Asymmetric Resource Consumption (Amplification) via the `extendedparser` and `urlencoded` functions when the URL encoding process is enabled. An attacker can flood the server with a large number of specially crafted requests.
## Remediation
Upgrade `body-parser` to version 1.20.3 or higher.
## References
- [GitHub Commit](https://github.com/expressjs/body-parser/commit/b2695c4450f06ba3b0ccf48d872a229bb41c9bce)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#15</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Excessive Platform Resource Consumption within a Loop</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[braces](https://www.npmjs.com/package/braces) is a Bash-like brace expansion, implemented in JavaScript.

Affected versions of this package are vulnerable to Excessive Platform Resource Consumption within a Loop due improper limitation of the number of characters it can handle, through the `parse` function. An attacker can cause the application to allocate excessive memory and potentially crash by sending imbalanced braces as input.
## PoC
```js
const { braces } = require(&#x27;micromatch&#x27;);

console.log(&quot;Executing payloads...&quot;);

const maxRepeats = 10;

for (let repeats = 1; repeats &lt;= maxRepeats; repeats += 1) {
  const payload = &#x27;{&#x27;.repeat(repeats*90000);

  console.log(`Testing with ${repeats} repeats...`);
  const startTime = Date.now();
  braces(payload);
  const endTime = Date.now();
  const executionTime = endTime - startTime;
  console.log(`Regex executed in ${executionTime / 1000}s.\n`);
} 
```
## Remediation
Upgrade `braces` to version 3.0.3 or higher.
## References
- [GitHub Commit](https://github.com/micromatch/braces/commit/a5851e57f45c3431a94d83fc565754bc10f5bbc3)
- [GitHub Issue](https://github.com/micromatch/braces/issues/35)
- [GitHub PR](https://github.com/micromatch/braces/pull/37)
- [Vulnerable Code](https://github.com/micromatch/braces/blob/98414f9f1fabe021736e26836d8306d5de747e0d/lib/parse.js#L308)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#16</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Excessive Platform Resource Consumption within a Loop</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[braces](https://www.npmjs.com/package/braces) is a Bash-like brace expansion, implemented in JavaScript.

Affected versions of this package are vulnerable to Excessive Platform Resource Consumption within a Loop due improper limitation of the number of characters it can handle, through the `parse` function. An attacker can cause the application to allocate excessive memory and potentially crash by sending imbalanced braces as input.
## PoC
```js
const { braces } = require(&#x27;micromatch&#x27;);

console.log(&quot;Executing payloads...&quot;);

const maxRepeats = 10;

for (let repeats = 1; repeats &lt;= maxRepeats; repeats += 1) {
  const payload = &#x27;{&#x27;.repeat(repeats*90000);

  console.log(`Testing with ${repeats} repeats...`);
  const startTime = Date.now();
  braces(payload);
  const endTime = Date.now();
  const executionTime = endTime - startTime;
  console.log(`Regex executed in ${executionTime / 1000}s.\n`);
} 
```
## Remediation
Upgrade `braces` to version 3.0.3 or higher.
## References
- [GitHub Commit](https://github.com/micromatch/braces/commit/a5851e57f45c3431a94d83fc565754bc10f5bbc3)
- [GitHub Issue](https://github.com/micromatch/braces/issues/35)
- [GitHub PR](https://github.com/micromatch/braces/pull/37)
- [Vulnerable Code](https://github.com/micromatch/braces/blob/98414f9f1fabe021736e26836d8306d5de747e0d/lib/parse.js#L308)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#17</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Excessive Platform Resource Consumption within a Loop</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[braces](https://www.npmjs.com/package/braces) is a Bash-like brace expansion, implemented in JavaScript.

Affected versions of this package are vulnerable to Excessive Platform Resource Consumption within a Loop due improper limitation of the number of characters it can handle, through the `parse` function. An attacker can cause the application to allocate excessive memory and potentially crash by sending imbalanced braces as input.
## PoC
```js
const { braces } = require(&#x27;micromatch&#x27;);

console.log(&quot;Executing payloads...&quot;);

const maxRepeats = 10;

for (let repeats = 1; repeats &lt;= maxRepeats; repeats += 1) {
  const payload = &#x27;{&#x27;.repeat(repeats*90000);

  console.log(`Testing with ${repeats} repeats...`);
  const startTime = Date.now();
  braces(payload);
  const endTime = Date.now();
  const executionTime = endTime - startTime;
  console.log(`Regex executed in ${executionTime / 1000}s.\n`);
} 
```
## Remediation
Upgrade `braces` to version 3.0.3 or higher.
## References
- [GitHub Commit](https://github.com/micromatch/braces/commit/a5851e57f45c3431a94d83fc565754bc10f5bbc3)
- [GitHub Issue](https://github.com/micromatch/braces/issues/35)
- [GitHub PR](https://github.com/micromatch/braces/pull/37)
- [Vulnerable Code](https://github.com/micromatch/braces/blob/98414f9f1fabe021736e26836d8306d5de747e0d/lib/parse.js#L308)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#18</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Internal Property Tampering</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[bson](https://www.npmjs.com/package/bson) is a BSON Parser for node and browser.

Affected versions of this package are vulnerable to Internal Property Tampering. The package will ignore an unknown value for an object&#x27;s `_bsotype`, leading to cases where an object is serialized as a document rather than the intended BSON type.


 **NOTE:** This vulnerability has also been identified as: [CVE-2019-2391](https://security.snyk.io/vuln/SNYK-JS-BSON-6056525)

## Remediation
Upgrade `bson` to version 1.1.4 or higher.
## References
- [GitHub Commit](https://github.com/mongodb/js-bson/commit/3809c1313a7b2a8001065f0271199df9fa3d16a8)
- [Release Note](https://github.com/mongodb/js-bson/releases/tag/v1.1.4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#19</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Internal Property Tampering</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[bson](https://www.npmjs.com/package/bson) is a BSON Parser for node and browser.

Affected versions of this package are vulnerable to Internal Property Tampering. The package will ignore an unknown value for an object&#x27;s `_bsotype`, leading to cases where an object is serialized as a document rather than the intended BSON type.


 **NOTE:** This vulnerability has also been identified as: [CVE-2020-7610](https://security.snyk.io/vuln/SNYK-JS-BSON-561052)

## Remediation
Upgrade `bson` to version 1.1.4 or higher.
## References
- [GitHub Commit](https://github.com/mongodb/js-bson/commit/3809c1313a7b2a8001065f0271199df9fa3d16a8)
- [Release Note](https://github.com/mongodb/js-bson/releases/tag/v1.1.4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#20</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#21</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#22</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#23</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#24</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#25</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#26</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#27</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#28</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#29</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#30</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Denial of Service (DoS) due to improper input validation, when the hash string `# kun%ea%ba%5a%ba` is being parsed by `decodeUriComponent`.

## PoC
```js
const decodeUriComponent = require(&#x27;decode-uri-component&#x27;);

var x = decodeUriComponent(&#x27;%ea%ba%5a%ba&#x27;);

console.log(x);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `decode-uri-component` to version 0.2.2 or higher.
## References
- [GitHub Commit](https://github.com/SamVerschueren/decode-uri-component/commit/980e0bf09b64d94f1aa79012f895816c30ffd152)
- [GitHub Issue](https://github.com/SamVerschueren/decode-uri-component/issues/5)
- [GitHub Issue](https://github.com/sindresorhus/query-string/issues/345)
- [GitHub Release](https://github.com/SamVerschueren/decode-uri-component/releases/tag/v0.2.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#31</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[ini](https://www.npmjs.org/package/ini) is an An ini encoder/decoder for node

Affected versions of this package are vulnerable to Prototype Pollution. If an attacker submits a malicious INI file to an application that parses it with `ini.parse`, they will pollute the prototype on the application. This can be exploited further depending on the context.

## PoC by Eugene Lim

payload.ini
```
[__proto__]
polluted = &quot;polluted&quot;
```

poc.js:
```
var fs = require(&#x27;fs&#x27;)
var ini = require(&#x27;ini&#x27;)

var parsed = ini.parse(fs.readFileSync(&#x27;./payload.ini&#x27;, &#x27;utf-8&#x27;))
console.log(parsed)
console.log(parsed.__proto__)
console.log(polluted)
```

```
&gt; node poc.js
{}
{ polluted: &#x27;polluted&#x27; }
{ polluted: &#x27;polluted&#x27; }
polluted
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `ini` to version 1.3.6 or higher.
## References
- [Eugene Lim - Research Blog Post](https://medium.com/csg-govtech/supply-chain-pollution-discovering-a-16-million-download-week-node-js-2fa4d2c27cf7)
- [GitHub Commit](https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#32</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[ini](https://www.npmjs.org/package/ini) is an An ini encoder/decoder for node

Affected versions of this package are vulnerable to Prototype Pollution. If an attacker submits a malicious INI file to an application that parses it with `ini.parse`, they will pollute the prototype on the application. This can be exploited further depending on the context.

## PoC by Eugene Lim

payload.ini
```
[__proto__]
polluted = &quot;polluted&quot;
```

poc.js:
```
var fs = require(&#x27;fs&#x27;)
var ini = require(&#x27;ini&#x27;)

var parsed = ini.parse(fs.readFileSync(&#x27;./payload.ini&#x27;, &#x27;utf-8&#x27;))
console.log(parsed)
console.log(parsed.__proto__)
console.log(polluted)
```

```
&gt; node poc.js
{}
{ polluted: &#x27;polluted&#x27; }
{ polluted: &#x27;polluted&#x27; }
polluted
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `ini` to version 1.3.6 or higher.
## References
- [Eugene Lim - Research Blog Post](https://medium.com/csg-govtech/supply-chain-pollution-discovering-a-16-million-download-week-node-js-2fa4d2c27cf7)
- [GitHub Commit](https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#33</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[ini](https://www.npmjs.org/package/ini) is an An ini encoder/decoder for node

Affected versions of this package are vulnerable to Prototype Pollution. If an attacker submits a malicious INI file to an application that parses it with `ini.parse`, they will pollute the prototype on the application. This can be exploited further depending on the context.

## PoC by Eugene Lim

payload.ini
```
[__proto__]
polluted = &quot;polluted&quot;
```

poc.js:
```
var fs = require(&#x27;fs&#x27;)
var ini = require(&#x27;ini&#x27;)

var parsed = ini.parse(fs.readFileSync(&#x27;./payload.ini&#x27;, &#x27;utf-8&#x27;))
console.log(parsed)
console.log(parsed.__proto__)
console.log(polluted)
```

```
&gt; node poc.js
{}
{ polluted: &#x27;polluted&#x27; }
{ polluted: &#x27;polluted&#x27; }
polluted
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `ini` to version 1.3.6 or higher.
## References
- [Eugene Lim - Research Blog Post](https://medium.com/csg-govtech/supply-chain-pollution-discovering-a-16-million-download-week-node-js-2fa4d2c27cf7)
- [GitHub Commit](https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#34</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[ini](https://www.npmjs.org/package/ini) is an An ini encoder/decoder for node

Affected versions of this package are vulnerable to Prototype Pollution. If an attacker submits a malicious INI file to an application that parses it with `ini.parse`, they will pollute the prototype on the application. This can be exploited further depending on the context.

## PoC by Eugene Lim

payload.ini
```
[__proto__]
polluted = &quot;polluted&quot;
```

poc.js:
```
var fs = require(&#x27;fs&#x27;)
var ini = require(&#x27;ini&#x27;)

var parsed = ini.parse(fs.readFileSync(&#x27;./payload.ini&#x27;, &#x27;utf-8&#x27;))
console.log(parsed)
console.log(parsed.__proto__)
console.log(polluted)
```

```
&gt; node poc.js
{}
{ polluted: &#x27;polluted&#x27; }
{ polluted: &#x27;polluted&#x27; }
polluted
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `ini` to version 1.3.6 or higher.
## References
- [Eugene Lim - Research Blog Post](https://medium.com/csg-govtech/supply-chain-pollution-discovering-a-16-million-download-week-node-js-2fa4d2c27cf7)
- [GitHub Commit](https://github.com/npm/ini/commit/56d2805e07ccd94e2ba0984ac9240ff02d44b6f1)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#35</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS). An attacker could bypass its output sanitization (`sanitize: true`) protection. Using the [HTML Coded Character Set](https://www.w3.org/MarkUp/html-spec/html-spec_13.html#SEC13), attackers can inject `javascript:` code snippets into the output. For example, the following input `javascript&amp;#x58document;alert&amp;#40;1&amp;#41;`  will result in `alert(1)` being executed when the user clicks on the link.
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `marked` to version 0.3.6 or higher.
## References
- [GitHub Commit](https://github.com/chjj/marked/pull/592/commits/2cff85979be8e7a026a9aca35542c470cf5da523)
- [GitHub PR](https://github.com/chjj/marked/pull/592)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#36</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS). Data URIs enable embedding small files in line in HTML documents, provided in the URL itself.
Attackers can craft malicious web pages containing either HTML or script code that utilizes the data URI scheme, allowing them to bypass access controls or steal sensitive information.

An example of data URI used to deliver javascript code. The data holds `&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;` tag in base64 encoded format.
```html
[xss link](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)
```
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `marked` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/chjj/marked/commit/cd2f6f5b7091154c5526e79b5f3bfb4d15995a51)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#37</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS). Browsers support both lowercase and uppercase x in hexadecimal form of HTML character entity, but marked [unescaped only lowercase](https://github.com/chjj/marked/blob/v0.3.7/lib/marked.js#L1096-L1108).

This may allow an attacker to create a link with javascript code.

For example:
```js
var marked = require(&#x27;marked&#x27;);
marked.setOptions({
  renderer: new marked.Renderer(),
  sanitize: true
});

text = `
lower[click me](javascript&amp;#x3a;...)lower
upper[click me](javascript&amp;#X3a;...)upper
`;

console.log(marked(text));
```

will render the following:

```html
&lt;p&gt;lowerlower
upper&lt;a href=&quot;javascript&amp;#X3a;...&quot;&gt;click me&lt;/a&gt;upper&lt;/p&gt;

```
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `marked` to version 0.3.9 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/pull/976/commits/6d1901ff71abb83aa32ca9a5ce47471382ea42a9)
- [GitHub Issue](https://github.com/chjj/marked/issues/925)
- [GitHub PR](https://github.com/chjj/marked/pull/958)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#38</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.


Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS)
when parsing the input markdown content (1,000 characters costs around 6 seconds matching time).

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation

Upgrade `marked` to version 0.3.9 or higher.


## References

- [GitHub Issue](https://github.com/chjj/marked/issues/937)

- [GitHub PR](https://github.com/chjj/marked/pull/958)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#39</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). This can cause an impact of about 10 seconds matching time for data 150 characters long.

## Disclosure Timeline
* Feb 21th, 2018 - Initial Disclosure to package owner
* Feb 21th, 2018 - Initial Response from package owner
* Feb 26th, 2018 - Fix issued
* Feb 27th, 2018 - Vulnerability published

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 0.3.18 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/pull/1083/commits/b15e42b67cec9ded8505e9d68bb8741ad7a9590d)
- [GitHub Issue](https://github.com/markedjs/marked/issues/1070)
- [GitHub PR](https://github.com/markedjs/marked/pull/1083)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#40</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#41</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#42</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#43</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#44</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#45</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#46</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#47</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#48</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#49</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#50</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mixin-deep](https://www.npmjs.com/package/mixin-deep) is a package that deeply mixes the properties of objects into the first object.

Affected versions of this package are vulnerable to Prototype Pollution. The function `mixin-deep` could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` payload.

## PoC by Snyk
```
const mixin = require(&#x27;mixin-deep&#x27;);
const payload = &#x27;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#x27;

function check() {
    mixin({}, JSON.parse(payload));
    if (({})[`a0`] === true) {
          console.log(`Vulnerable to Prototype Pollution via ${payload}`)
  }
}

check();
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mixin-deep` to version 2.0.1, 1.3.2 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/mixin-deep/commit/8f464c8ce9761a8c9c2b3457eaeee9d404fa7af9)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#51</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service (DoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[mongodb](https://www.npmjs.com/package/mongodb) is an official MongoDB driver for Node.js.

Affected versions of this package are vulnerable to Denial of Service (DoS). The package fails to properly catch an exception when a collection name is invalid and the DB does not exist, crashing the application.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `mongodb` to version 3.1.13 or higher.
## References
- [NPM Security Advisory](https://www.npmjs.com/advisories/1203)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#52</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[nconf](https://www.npmjs.com/package/nconf) is a Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.

Affected versions of this package are vulnerable to Prototype Pollution. When using the `memory` engine, it is possible to store a nested JSON representation of the configuration. The `.set()` function, that is responsible for setting the configuration properties, is vulnerable to Prototype Pollution. By providing a crafted property, it is possible to modify the properties on the `Object.prototype`.


## PoC

```javascript
const nconf = require(&#x27;nconf&#x27;);
nconf.use(&#x27;memory&#x27;)

console.log({}.polluted)

nconf.set(&#x27;__proto__:polluted&#x27;, &#x27;yes&#x27;)

console.log({}.polluted)
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `nconf` to version 0.11.4 or higher.
## References
- [GitHub PR](https://github.com/indexzero/nconf/pull/397)
- [GitHub Release](https://github.com/indexzero/nconf/releases/tag/v0.11.4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#53</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[nconf](https://www.npmjs.com/package/nconf) is a Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.

Affected versions of this package are vulnerable to Prototype Pollution. When using the `memory` engine, it is possible to store a nested JSON representation of the configuration. The `.set()` function, that is responsible for setting the configuration properties, is vulnerable to Prototype Pollution. By providing a crafted property, it is possible to modify the properties on the `Object.prototype`.


## PoC

```javascript
const nconf = require(&#x27;nconf&#x27;);
nconf.use(&#x27;memory&#x27;)

console.log({}.polluted)

nconf.set(&#x27;__proto__:polluted&#x27;, &#x27;yes&#x27;)

console.log({}.polluted)
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `nconf` to version 0.11.4 or higher.
## References
- [GitHub PR](https://github.com/indexzero/nconf/pull/397)
- [GitHub Release](https://github.com/indexzero/nconf/releases/tag/v0.11.4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#54</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[nconf](https://www.npmjs.com/package/nconf) is a Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.

Affected versions of this package are vulnerable to Prototype Pollution. When using the `memory` engine, it is possible to store a nested JSON representation of the configuration. The `.set()` function, that is responsible for setting the configuration properties, is vulnerable to Prototype Pollution. By providing a crafted property, it is possible to modify the properties on the `Object.prototype`.


## PoC

```javascript
const nconf = require(&#x27;nconf&#x27;);
nconf.use(&#x27;memory&#x27;)

console.log({}.polluted)

nconf.set(&#x27;__proto__:polluted&#x27;, &#x27;yes&#x27;)

console.log({}.polluted)
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `nconf` to version 0.11.4 or higher.
## References
- [GitHub PR](https://github.com/indexzero/nconf/pull/397)
- [GitHub Release](https://github.com/indexzero/nconf/releases/tag/v0.11.4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#55</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Poisoning</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[qs](https://www.npmjs.com/package/qs) is a querystring parser that supports nesting and arrays, with a depth limit.

Affected versions of this package are vulnerable to Prototype Poisoning which allows attackers to cause a Node process to hang, processing an Array object whose prototype has been replaced by one with an excessive length value.

**Note:** In many typical Express use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as `a[__proto__]=b&amp;a[__proto__]&amp;a[length]=100000000`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `qs` to version 6.2.4, 6.3.3, 6.4.1, 6.5.3, 6.6.1, 6.7.3, 6.8.3, 6.9.7, 6.10.3 or higher.
## References
- [GitHub PR](https://github.com/ljharb/qs/pull/428)
- [RedHat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2150323)
- [Researcher Advisory](https://github.com/n8tz/CVE-2022-24999)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#56</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Poisoning</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[qs](https://www.npmjs.com/package/qs) is a querystring parser that supports nesting and arrays, with a depth limit.

Affected versions of this package are vulnerable to Prototype Poisoning which allows attackers to cause a Node process to hang, processing an Array object whose prototype has been replaced by one with an excessive length value.

**Note:** In many typical Express use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as `a[__proto__]=b&amp;a[__proto__]&amp;a[length]=100000000`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `qs` to version 6.2.4, 6.3.3, 6.4.1, 6.5.3, 6.6.1, 6.7.3, 6.8.3, 6.9.7, 6.10.3 or higher.
## References
- [GitHub PR](https://github.com/ljharb/qs/pull/428)
- [RedHat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2150323)
- [Researcher Advisory](https://github.com/n8tz/CVE-2022-24999)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#57</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Poisoning</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[qs](https://www.npmjs.com/package/qs) is a querystring parser that supports nesting and arrays, with a depth limit.

Affected versions of this package are vulnerable to Prototype Poisoning which allows attackers to cause a Node process to hang, processing an Array object whose prototype has been replaced by one with an excessive length value.

**Note:** In many typical Express use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as `a[__proto__]=b&amp;a[__proto__]&amp;a[length]=100000000`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.

Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.

One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.

When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.

Two common types of DoS vulnerabilities:

* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](https://security.snyk.io/vuln/SNYK-JAVA-COMMONSFILEUPLOAD-30082).

* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](https://snyk.io/vuln/npm:ws:20171108)

## Remediation
Upgrade `qs` to version 6.2.4, 6.3.3, 6.4.1, 6.5.3, 6.6.1, 6.7.3, 6.8.3, 6.9.7, 6.10.3 or higher.
## References
- [GitHub PR](https://github.com/ljharb/qs/pull/428)
- [RedHat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2150323)
- [Researcher Advisory](https://github.com/n8tz/CVE-2022-24999)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#58</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[semver](https://github.com/npm/node-semver) is a semantic version parser used by npm.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the function `new Range`, when untrusted user data is provided as a range.


## PoC

```js

const semver = require(&#x27;semver&#x27;)
const lengths_2 = [2000, 4000, 8000, 16000, 32000, 64000, 128000]

console.log(&quot;n[+] Valid range - Test payloads&quot;)
for (let i = 0; i =1.2.3&#x27; + &#x27; &#x27;.repeat(lengths_2[i]) + &#x27;&lt;1.3.0&#x27;;
const start = Date.now()
semver.validRange(value)
// semver.minVersion(value)
// semver.maxSatisfying([&quot;1.2.3&quot;], value)
// semver.minSatisfying([&quot;1.2.3&quot;], value)
// new semver.Range(value, {})

const end = Date.now();
console.log(&#x27;length=%d, time=%d ms&#x27;, value.length, end - start);
}
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `semver` to version 5.7.2, 6.3.1, 7.5.2 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-semver/commit/2f8fd41487acf380194579ecb6f8b1bbfe116be0)
- [GitHub Commit](https://github.com/npm/node-semver/commit/717534ee353682f3bcf33e60a8af4292626d4441)
- [GitHub Commit](https://github.com/npm/node-semver/commit/928e56d21150da0413a3333a3148b20e741a920c)
- [GitHub PR](https://github.com/npm/node-semver/pull/564)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/classes/range.js#L97-L104)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/internal/re.js#L138)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/internal/re.js#L160)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#59</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[semver](https://github.com/npm/node-semver) is a semantic version parser used by npm.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the function `new Range`, when untrusted user data is provided as a range.


## PoC

```js

const semver = require(&#x27;semver&#x27;)
const lengths_2 = [2000, 4000, 8000, 16000, 32000, 64000, 128000]

console.log(&quot;n[+] Valid range - Test payloads&quot;)
for (let i = 0; i =1.2.3&#x27; + &#x27; &#x27;.repeat(lengths_2[i]) + &#x27;&lt;1.3.0&#x27;;
const start = Date.now()
semver.validRange(value)
// semver.minVersion(value)
// semver.maxSatisfying([&quot;1.2.3&quot;], value)
// semver.minSatisfying([&quot;1.2.3&quot;], value)
// new semver.Range(value, {})

const end = Date.now();
console.log(&#x27;length=%d, time=%d ms&#x27;, value.length, end - start);
}
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `semver` to version 5.7.2, 6.3.1, 7.5.2 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-semver/commit/2f8fd41487acf380194579ecb6f8b1bbfe116be0)
- [GitHub Commit](https://github.com/npm/node-semver/commit/717534ee353682f3bcf33e60a8af4292626d4441)
- [GitHub Commit](https://github.com/npm/node-semver/commit/928e56d21150da0413a3333a3148b20e741a920c)
- [GitHub PR](https://github.com/npm/node-semver/pull/564)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/classes/range.js#L97-L104)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/internal/re.js#L138)
- [Vulnerable Code](https://github.com/npm/node-semver/blob/main/internal/re.js#L160)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#60</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#61</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#62</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#63</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#64</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#65</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#66</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#67</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#68</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#69</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#70</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#71</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#72</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#73</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#74</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#75</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#76</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#77</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#78</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#79</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#80</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#81</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#82</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#83</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#84</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#85</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#86</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#87</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#88</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#89</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#90</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#91</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#92</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#93</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#94</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#95</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#96</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#97</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#98</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#99</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#100</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#101</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#102</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the `path` parameter are arrays.


### PoC
```
const set = require(&quot;set-value&quot;)

// set({}, [&#x27;__proto__&#x27;,&#x27;polluted&#x27;], &#x27;yes&#x27;);
// console.log(polluted); // Error: Cannot set unsafe key: &quot;__proto__&quot;

set({}, [[&#x27;__proto__&#x27;],&#x27;polluted&#x27;], &#x27;yes&#x27;);
console.log(polluted);
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.3, 4.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/09c4b108fea3c0260008590053ff13da64913245)
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/7cf8073bb06bf0c15e08475f9f952823b4576452)
- [GitHub PR](https://github.com/jonschlinkert/set-value/pull/33)
- [Huntr Bounty Report](https://www.huntr.dev/bounties/2eae1159-01de-4f82-a177-7478a408c4a2/)
- [Snyk Blog](https://snyk.io/blog/remediate-javascript-type-confusion-bypassed-input-validation/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#103</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[set-value](https://www.npmjs.com/package/set-value) is a package that creates nested values and any intermediaries using dot notation (&#x27;a.b.c&#x27;) paths.

Affected versions of this package are vulnerable to Prototype Pollution. The function `set-value` could be tricked into adding or modifying properties of `Object.prototype` using any of the `constructor`, `prototype` and `_proto_` payloads.

## PoC by Snyk
```
const setFn = require(&#x27;set-value&#x27;);
const paths = [
  &#x27;constructor.prototype.a0&#x27;,
  &#x27;__proto__.a1&#x27;,
];

function check() {
  for (const p of paths) {
      setFn({}, p, true);
  }
  for (let i = 0; i &lt; paths.length; i++) {
      if (({})[`a${i}`] === true) {
          console.log(`Yes with ${paths[i]}`);
      }
  }
}

check();

```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `set-value` to version 2.0.1, 3.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/set-value/commit/95e9d9923f8a8b4a01da1ea138fcc39ec7b6b15f)
- [NPM Security Advisory](https://nodesecurity.io/advisories/1012)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#104</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary File Overwrite</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Arbitrary File Overwrite. This is due to insufficient symlink protection.
`node-tar` aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks.  Additionally, in order to prevent unnecessary `stat` calls to determine whether a given path is a directory, paths are cached when directories are created.

This logic is insufficient when extracting tar files that contain both a directory and a symlink with the same name as the directory. This order of operations results in the directory being created and added to the `node-tar` directory cache. When a directory is present in the directory cache, subsequent calls to `mkdir` for that directory are skipped.
However, this is also where `node-tar` checks for symlinks occur. By first creating a directory, and then replacing that directory with a symlink, it is possible to bypass `node-tar` symlink checks on directories, essentially allowing an untrusted tar file to symlink into an arbitrary location and subsequently extracting arbitrary files into that location.
## Remediation
Upgrade `tar` to version 3.2.3, 4.4.15, 5.0.7, 6.1.2 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/9dbdeb6df8e9dbd96fa9e84341b9d74734be6c20)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#105</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary File Overwrite</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Arbitrary File Overwrite. This is due to insufficient absolute path sanitization.

`node-tar` aims to prevent extraction of absolute file paths by turning absolute paths into relative paths when the `preservePaths` flag is not set to `true`. This is achieved by stripping the absolute path root from any absolute file paths contained in a tar file. For example, the path `/home/user/.bashrc` would turn into `home/user/.bashrc`.

This logic is insufficient when file paths contain repeated path roots such as `////home/user/.bashrc`. `node-tar` only strips a single path root from such paths. When given an absolute file path with repeating path roots, the resulting path (e.g. `///home/user/.bashrc`) still resolves to an absolute path.
## Remediation
Upgrade `tar` to version 3.2.2, 4.4.14, 5.0.6, 6.1.1 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/1f036ca23f64a547bdd6c79c1a44bc62e8115da4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#106</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary File Write</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Arbitrary File Write. `node-tar` aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks. Additionally, in order to prevent unnecessary stat calls to determine whether a given path is a directory, paths are cached when directories are created.

This logic was insufficient when extracting `tar` files that contained both a directory and a symlink with the same name as the directory, where the symlink and directory names in the archive entry used backslashes as a path separator on posix systems. The cache checking logic used both `\` and `/` characters as path separators. However, `\` is a valid filename character on posix systems.

By first creating a directory, and then replacing that directory with a symlink, it is possible to bypass `node-tar` symlink checks on directories, essentially allowing an untrusted `tar` file to symlink into an arbitrary location. This can lead to extracting arbitrary files into that location, thus allowing arbitrary file creation and overwrite.

Additionally, a similar confusion could arise on case-insensitive filesystems. If a `tar` archive contained a directory at `FOO`, followed by a symbolic link named `foo`, then on case-insensitive file systems, the creation of the symbolic link would remove the directory from the filesystem, but not from the internal directory cache, as it would not be treated as a cache hit. A subsequent file entry within the `FOO` directory would then be placed in the target of the symbolic link, thinking that the directory had already been created.
## Remediation
Upgrade `tar` to version 6.1.7, 5.0.8, 4.4.16 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/53602669f58ddbeb3294d7196b3320aaaed22728)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#107</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary File Write</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Arbitrary File Write. `node-tar` aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks. Additionally, in order to prevent unnecessary stat calls to determine whether a given path is a directory, paths are cached when directories are created.

This logic is insufficient when extracting `tar` files that contain two directories and a symlink with names containing unicode values that normalized to the same value. Additionally, on Windows systems, long path portions would resolve to the same file system entities as their 8.3 &quot;short path&quot; counterparts.
A specially crafted `tar` archive can include directories with two forms of the path that resolve to the same file system entity, followed by a symbolic link with a name in the first form, lastly followed by a file using the second form. This leads to bypassing `node-tar` symlink checks on directories, essentially allowing an untrusted `tar` file to symlink into an arbitrary location and extracting arbitrary files into that location.
## Remediation
Upgrade `tar` to version 6.1.9, 5.0.10, 4.4.18 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/b6162c7fafe797f856564ef37f4b82747f051455)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#108</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary File Write</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Arbitrary File Write. `node-tar` aims to guarantee that any file whose location would be outside of the extraction target directory is not extracted. This is, in part, accomplished by sanitizing absolute paths of entries within the archive, skipping archive entries that contain `..` path portions, and resolving the sanitized paths against the extraction target directory.

This logic is insufficient on Windows systems when extracting `tar` files that contain a path that is not an absolute path, but specify a drive letter different from the extraction target, such as `C:some\path`. If the drive letter does not match the extraction target, for example `D:\extraction\dir`, then the result of `path.resolve(extractionDirectory, entryPath)` resolves against the current working directory on the `C:` drive, rather than the extraction target directory.

Additionally, a `..` portion of the path can occur immediately after the drive letter, such as `C:../foo`, and is not properly sanitized by the logic that checks for `..` within the normalized and split portions of the path.

**Note:** This only affects users of `node-tar` on Windows systems.
## Remediation
Upgrade `tar` to version 6.1.9, 5.0.10, 4.4.18 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/875a37e3ec031186fc6599f6807341f56c584598)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#109</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#110</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#111</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#112</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#113</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#114</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#115</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#116</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#117</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#118</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#119</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Prototype Pollution via the `unset` function in `index.js`, because it allows access to object prototype properties.

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `unset-value` to version 2.0.1 or higher.
## References
- [GitHub Commit](https://github.com/jonschlinkert/unset-value/pull/12/commits/abb534769f6ea62c3dd988f5ce0a4ebd1f91b561)
- [GitHub Issue](https://github.com/jonschlinkert/unset-value/issues/11)
- [GitHub PR](https://github.com/jonschlinkert/unset-value/pull/12)
- [GitHub Release](https://github.com/jonschlinkert/unset-value/releases)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#120</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://github.com/flatiron/utile) is a drop-in replacement for `util` with some additional advantageous functions.

Affected versions of this package are vulnerable to Prototype Pollution through the `createPath` function. An attacker can disrupt service by supplying a crafted payload with `Object.prototype` setter to introduce or modify properties within the global prototype chain.
## PoC
```js
(async () =&gt; {
const lib = await import(&#x27;utile&#x27;);
var someObj = {}
console.log(&quot;Before Attack: &quot;, JSON.stringify({}.__proto__));
try {
// for multiple functions, uncomment only one for each execution.
lib.createPath (someObj, [[&quot;__proto__&quot;], &quot;pollutedKey&quot;], &quot;pollutedValue&quot;)
} catch (e) { }
console.log(&quot;After Attack: &quot;, JSON.stringify({}.__proto__));
delete Object.prototype.pollutedKey;
})();
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
There is no fixed version for `utile`.
## References
- [GitHub Gist](https://gist.github.com/tariqhawis/7b2c50ccdec39a030091e48a4ccde688)
- [Vulnerable Code](https://github.com/flatiron/utile/blob/master/lib/index.js#L242)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#121</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://github.com/flatiron/utile) is a drop-in replacement for `util` with some additional advantageous functions.

Affected versions of this package are vulnerable to Prototype Pollution through the `createPath` function. An attacker can disrupt service by supplying a crafted payload with `Object.prototype` setter to introduce or modify properties within the global prototype chain.
## PoC
```js
(async () =&gt; {
const lib = await import(&#x27;utile&#x27;);
var someObj = {}
console.log(&quot;Before Attack: &quot;, JSON.stringify({}.__proto__));
try {
// for multiple functions, uncomment only one for each execution.
lib.createPath (someObj, [[&quot;__proto__&quot;], &quot;pollutedKey&quot;], &quot;pollutedValue&quot;)
} catch (e) { }
console.log(&quot;After Attack: &quot;, JSON.stringify({}.__proto__));
delete Object.prototype.pollutedKey;
})();
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
There is no fixed version for `utile`.
## References
- [GitHub Gist](https://gist.github.com/tariqhawis/7b2c50ccdec39a030091e48a4ccde688)
- [Vulnerable Code](https://github.com/flatiron/utile/blob/master/lib/index.js#L242)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#122</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://github.com/flatiron/utile) is a drop-in replacement for `util` with some additional advantageous functions.

Affected versions of this package are vulnerable to Prototype Pollution through the `createPath` function. An attacker can disrupt service by supplying a crafted payload with `Object.prototype` setter to introduce or modify properties within the global prototype chain.
## PoC
```js
(async () =&gt; {
const lib = await import(&#x27;utile&#x27;);
var someObj = {}
console.log(&quot;Before Attack: &quot;, JSON.stringify({}.__proto__));
try {
// for multiple functions, uncomment only one for each execution.
lib.createPath (someObj, [[&quot;__proto__&quot;], &quot;pollutedKey&quot;], &quot;pollutedValue&quot;)
} catch (e) { }
console.log(&quot;After Attack: &quot;, JSON.stringify({}.__proto__));
delete Object.prototype.pollutedKey;
})();
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
There is no fixed version for `utile`.
## References
- [GitHub Gist](https://gist.github.com/tariqhawis/7b2c50ccdec39a030091e48a4ccde688)
- [Vulnerable Code](https://github.com/flatiron/utile/blob/master/lib/index.js#L242)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#123</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://github.com/flatiron/utile) is a drop-in replacement for `util` with some additional advantageous functions.

Affected versions of this package are vulnerable to Prototype Pollution through the `createPath` function. An attacker can disrupt service by supplying a crafted payload with `Object.prototype` setter to introduce or modify properties within the global prototype chain.
## PoC
```js
(async () =&gt; {
const lib = await import(&#x27;utile&#x27;);
var someObj = {}
console.log(&quot;Before Attack: &quot;, JSON.stringify({}.__proto__));
try {
// for multiple functions, uncomment only one for each execution.
lib.createPath (someObj, [[&quot;__proto__&quot;], &quot;pollutedKey&quot;], &quot;pollutedValue&quot;)
} catch (e) { }
console.log(&quot;After Attack: &quot;, JSON.stringify({}.__proto__));
delete Object.prototype.pollutedKey;
})();
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
There is no fixed version for `utile`.
## References
- [GitHub Gist](https://gist.github.com/tariqhawis/7b2c50ccdec39a030091e48a4ccde688)
- [Vulnerable Code](https://github.com/flatiron/utile/blob/master/lib/index.js#L242)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#124</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://github.com/flatiron/utile) is a drop-in replacement for `util` with some additional advantageous functions.

Affected versions of this package are vulnerable to Prototype Pollution through the `createPath` function. An attacker can disrupt service by supplying a crafted payload with `Object.prototype` setter to introduce or modify properties within the global prototype chain.
## PoC
```js
(async () =&gt; {
const lib = await import(&#x27;utile&#x27;);
var someObj = {}
console.log(&quot;Before Attack: &quot;, JSON.stringify({}.__proto__));
try {
// for multiple functions, uncomment only one for each execution.
lib.createPath (someObj, [[&quot;__proto__&quot;], &quot;pollutedKey&quot;], &quot;pollutedValue&quot;)
} catch (e) { }
console.log(&quot;After Attack: &quot;, JSON.stringify({}.__proto__));
delete Object.prototype.pollutedKey;
})();
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
There is no fixed version for `utile`.
## References
- [GitHub Gist](https://gist.github.com/tariqhawis/7b2c50ccdec39a030091e48a4ccde688)
- [Vulnerable Code](https://github.com/flatiron/utile/blob/master/lib/index.js#L242)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#125</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[y18n](https://www.npmjs.com/package/y18n) is a the bare-bones internationalization library used by yargs

Affected versions of this package are vulnerable to Prototype Pollution due to improper sanitization.
## PoC by po6ix:
```js
const y18n = require(&#x27;y18n&#x27;)();
 
y18n.setLocale(&#x27;__proto__&#x27;);
y18n.updateLocale({polluted: true});

console.log(polluted); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `y18n` to version 3.2.2, 4.0.1, 5.0.5 or higher.
## References
- [GitHub Commit](https://github.com/yargs/y18n/commit/a9ac604abf756dec9687be3843e2c93bfe581f25)
- [GitHub Issue](https://github.com/yargs/y18n/issues/96)
- [GitHub PR](https://github.com/yargs/y18n/pull/108)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#126</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: double free after calling PEM_read_bio_ex</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and
decodes the &quot;name&quot; (e.g. &quot;CERTIFICATE&quot;), any header data and the payload data.
If the function succeeds then the &quot;name_out&quot;, &quot;header&quot; and &quot;data&quot; arguments are
populated with pointers to buffers containing the relevant decoded data. The
caller is responsible for freeing those buffers. It is possible to construct a
PEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()
will return a failure code but will populate the header argument with a pointer
to a buffer that has already been freed. If the caller also frees this buffer
then a double free will occur. This will most likely lead to a crash. This
could be exploited by an attacker who has the ability to supply malicious PEM
files for parsing to achieve a denial of service attack.

The functions PEM_read_bio() and PEM_read() are simple wrappers around
PEM_read_bio_ex() and therefore these functions are also directly affected.

These functions are also called indirectly by a number of other OpenSSL
functions including PEM_X509_INFO_read_bio_ex() and
SSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal
uses of these functions are not vulnerable because the caller does not free the
header argument if PEM_read_bio_ex() returns a failure code. These locations
include the PEM_read_bio_TYPE() functions as well as the decoders introduced in
OpenSSL 3.0.

The OpenSSL asn1parse command line application is also impacted by this issue.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#127</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: use-after-free following BIO_new_NDEF</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The public API function BIO_new_NDEF is a helper function used for streaming
ASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the
SMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by
end user applications.

The function receives a BIO from the caller, prepends a new BIO_f_asn1 filter
BIO onto the front of it to form a BIO chain, and then returns the new head of
the BIO chain to the caller. Under certain conditions, for example if a CMS
recipient public key is invalid, the new filter BIO is freed and the function
returns a NULL result indicating a failure. However, in this case, the BIO chain
is not properly cleaned up and the BIO passed by the caller still retains
internal pointers to the previously freed filter BIO. If the caller then goes on
to call BIO_pop() on the BIO then a use-after-free will occur. This will most
likely result in a crash.



This scenario occurs directly in the internal function B64_write_ASN1() which
may cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on
the BIO. This internal function is in turn called by the public API functions
PEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,
SMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.

Other public API functions that may be impacted by this include
i2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and
i2d_PKCS7_bio_stream.

The OpenSSL cms and smime command line applications are similarly affected.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#128</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: X.400 address type confusion in X.509 GeneralName</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">There is a type confusion vulnerability relating to X.400 address processing
inside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but
the public structure definition for GENERAL_NAME incorrectly specified the type
of the x400Address field as ASN1_TYPE. This field is subsequently interpreted by
the OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an
ASN1_STRING.

When CRL checking is enabled (i.e. the application sets the
X509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass
arbitrary pointers to a memcmp call, enabling them to read memory contents or
enact a denial of service. In most cases, the attack requires the attacker to
provide both the certificate chain and CRL, neither of which need to have a
valid signature. If the attacker only controls one of these inputs, the other
input must already contain an X.400 address as a CRL distribution point, which
is uncommon. As such, this vulnerability is most likely to only affect
applications which have implemented their own functionality for retrieving CRLs
over a network.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#129</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: Denial of service by excessive resource usage in verifying X509 policy constraints</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A security vulnerability has been identified in all supported versions

of OpenSSL related to the verification of X.509 certificate chains
that include policy constraints.  Attackers may be able to exploit this
vulnerability by creating a malicious certificate chain that triggers
exponential use of computational resources, leading to a denial-of-service
(DoS) attack on affected systems.

Policy processing is disabled by default but can be enabled by passing
the `-policy&#x27; argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()&#x27; function.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#130</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: double free after calling PEM_read_bio_ex</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and
decodes the &quot;name&quot; (e.g. &quot;CERTIFICATE&quot;), any header data and the payload data.
If the function succeeds then the &quot;name_out&quot;, &quot;header&quot; and &quot;data&quot; arguments are
populated with pointers to buffers containing the relevant decoded data. The
caller is responsible for freeing those buffers. It is possible to construct a
PEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()
will return a failure code but will populate the header argument with a pointer
to a buffer that has already been freed. If the caller also frees this buffer
then a double free will occur. This will most likely lead to a crash. This
could be exploited by an attacker who has the ability to supply malicious PEM
files for parsing to achieve a denial of service attack.

The functions PEM_read_bio() and PEM_read() are simple wrappers around
PEM_read_bio_ex() and therefore these functions are also directly affected.

These functions are also called indirectly by a number of other OpenSSL
functions including PEM_X509_INFO_read_bio_ex() and
SSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal
uses of these functions are not vulnerable because the caller does not free the
header argument if PEM_read_bio_ex() returns a failure code. These locations
include the PEM_read_bio_TYPE() functions as well as the decoders introduced in
OpenSSL 3.0.

The OpenSSL asn1parse command line application is also impacted by this issue.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#131</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: use-after-free following BIO_new_NDEF</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The public API function BIO_new_NDEF is a helper function used for streaming
ASN.1 data via a BIO. It is primarily used internally to OpenSSL to support the
SMIME, CMS and PKCS7 streaming capabilities, but may also be called directly by
end user applications.

The function receives a BIO from the caller, prepends a new BIO_f_asn1 filter
BIO onto the front of it to form a BIO chain, and then returns the new head of
the BIO chain to the caller. Under certain conditions, for example if a CMS
recipient public key is invalid, the new filter BIO is freed and the function
returns a NULL result indicating a failure. However, in this case, the BIO chain
is not properly cleaned up and the BIO passed by the caller still retains
internal pointers to the previously freed filter BIO. If the caller then goes on
to call BIO_pop() on the BIO then a use-after-free will occur. This will most
likely result in a crash.



This scenario occurs directly in the internal function B64_write_ASN1() which
may cause BIO_new_NDEF() to be called and will subsequently call BIO_pop() on
the BIO. This internal function is in turn called by the public API functions
PEM_write_bio_ASN1_stream, PEM_write_bio_CMS_stream, PEM_write_bio_PKCS7_stream,
SMIME_write_ASN1, SMIME_write_CMS and SMIME_write_PKCS7.

Other public API functions that may be impacted by this include
i2d_ASN1_bio_stream, BIO_new_CMS, BIO_new_PKCS7, i2d_CMS_bio_stream and
i2d_PKCS7_bio_stream.

The OpenSSL cms and smime command line applications are similarly affected.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#132</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: X.400 address type confusion in X.509 GeneralName</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">There is a type confusion vulnerability relating to X.400 address processing
inside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but
the public structure definition for GENERAL_NAME incorrectly specified the type
of the x400Address field as ASN1_TYPE. This field is subsequently interpreted by
the OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an
ASN1_STRING.

When CRL checking is enabled (i.e. the application sets the
X509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass
arbitrary pointers to a memcmp call, enabling them to read memory contents or
enact a denial of service. In most cases, the attack requires the attacker to
provide both the certificate chain and CRL, neither of which need to have a
valid signature. If the attacker only controls one of these inputs, the other
input must already contain an X.400 address as a CRL distribution point, which
is uncommon. As such, this vulnerability is most likely to only affect
applications which have implemented their own functionality for retrieving CRLs
over a network.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#133</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>oci_test_dacn_layout (alpine 3.15.4):</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">openssl: Denial of service by excessive resource usage in verifying X509 policy constraints</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A security vulnerability has been identified in all supported versions

of OpenSSL related to the verification of X.509 certificate chains
that include policy constraints.  Attackers may be able to exploit this
vulnerability by creating a malicious certificate chain that triggers
exponential use of computational resources, leading to a denial-of-service
(DoS) attack on affected systems.

Policy processing is disabled by default but can be enabled by passing
the `-policy&#x27; argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()&#x27; function.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#134</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#135</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#136</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#137</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#138</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">body-parser: Denial of Service Vulnerability in body-parser</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">body-parser is Node.js body parsing middleware. body-parser &lt;1.20.3 is vulnerable to denial of service when url encoding is enabled. A malicious actor using a specially crafted payload could flood the server with a large number of requests, resulting in denial of service. This issue is patched in 1.20.3.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#139</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">braces: fails to limit the number of characters it can handle</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The NPM package `braces`, versions prior to 3.0.3, fails to limit the number of characters it can handle, which could lead to Memory Exhaustion. In `lib/parse.js,` if a malicious user sends &quot;imbalanced braces&quot; as input, the parsing will enter a loop, which will cause the program to start allocating heap memory without freeing it at any moment of the loop. Eventually, the JavaScript heap limit is reached, and the program will crash.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#140</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">cross-spawn: regular expression denial of service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Versions of the package cross-spawn before 6.0.6, from 7.0.0 and before 7.0.5 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper input sanitization. An attacker can increase the CPU usage and crash the program by crafting a very large and well crafted string.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#141</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">A vulnerability classified as problematic has been found in debug-js d ...</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A vulnerability classified as problematic has been found in debug-js debug up to 3.0.x. This affects the function useColors of the file src/node.js. The manipulation of the argument str leads to inefficient regular expression complexity. Upgrading to version 3.1.0 is able to address this issue. The identifier of the patch is c38a0166c266a679c8de012d4eaccec3f944e685. It is recommended to upgrade the affected component. The identifier VDB-217665 was assigned to this vulnerability.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#142</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">decode-uri-component: improper input validation resulting in DoS</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">decode-uri-component 0.2.0 is vulnerable to Improper Input Validation resulting in DoS.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#143</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">decode-uri-component: improper input validation resulting in DoS</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">decode-uri-component 0.2.0 is vulnerable to Improper Input Validation resulting in DoS.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#144</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">http-cache-semantics: Regular Expression Denial of Service (ReDoS) vulnerability</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects versions of the package http-cache-semantics before 4.1.1. The issue can be exploited via malicious request header values sent to a server, when that server reads the cache policy from the request using this library.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#145</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">inflect vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">inflect is vulnerable to Inefficient Regular Expression Complexity</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#146</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-ini: Prototype pollution via malicious INI file</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects the package ini before 1.3.6. If an attacker submits a malicious INI file to an application that parses it with ini.parse, they will pollute the prototype on the application. This can be exploited further depending on the context.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#147</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">node-ip: Incomplete fix for CVE-2023-42282</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The ip package through 2.0.1 for Node.js might allow SSRF because some IP addresses (such as 127.1, 01200034567, 012.1.2.3, 000:0:0000::01, and ::fFFf:127.0.0.1) are improperly categorized as globally routable via isPublic. NOTE: this issue exists because of an incomplete fix for CVE-2023-42282.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#148</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#149</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#150</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#151</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#152</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#153</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-kind-of: ctorName in index.js allows external user input to overwrite certain internal attributes</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">ctorName in index.js in kind-of v6.0.2 allows external user input to overwrite certain internal attributes via a conflicting name, as demonstrated by &#x27;constructor&#x27;: {&#x27;name&#x27;:&#x27;Symbol&#x27;}. Hence, a crafted payload can overwrite this builtin attribute to manipulate the type detection result.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#154</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">The marked module is vulnerable to a regular expression denial of serv ...</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The marked module is vulnerable to a regular expression denial of service. Based on the information published in the public issue, 1k characters can block for around 6 seconds.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#155</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">marked: regular expression block.def may lead Denial of Service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Marked is a markdown parser and compiler. Prior to version 4.0.10, the regular expression `block.def` may cause catastrophic backtracking against some strings and lead to a regular expression denial of service (ReDoS). Anyone who runs untrusted markdown through a vulnerable version of marked and does not use a worker with a time limit may be affected. This issue is patched in version 4.0.10. As a workaround, avoid running untrusted markdown through marked or run marked on a worker thread and set a reasonable time limit to prevent draining resources.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#156</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">marked: regular expression inline.reflinkSearch may lead Denial of Service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Marked is a markdown parser and compiler. Prior to version 4.0.10, the regular expression `inline.reflinkSearch` may cause catastrophic backtracking against some strings and lead to a denial of service (DoS). Anyone who runs untrusted markdown through a vulnerable version of marked and does not use a worker with a time limit may be affected. This issue is patched in version 4.0.10. As a workaround, avoid running untrusted markdown through marked or run marked on a worker thread and set a reasonable time limit to prevent draining resources.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#157</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-minimatch: ReDoS via the braceExpand function</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A vulnerability was found in the minimatch package. This flaw allows a Regular Expression Denial of Service (ReDoS) when calling the braceExpand function with specific arguments, resulting in a Denial of Service.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#158</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-minimatch: ReDoS via the braceExpand function</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A vulnerability was found in the minimatch package. This flaw allows a Regular Expression Denial of Service (ReDoS) when calling the braceExpand function with specific arguments, resulting in a Denial of Service.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#159</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Denial of Service in mongodb</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Versions of `mongodb` prior to 3.1.13 are vulnerable to Denial of Service. The package fails to properly catch an exception when a collection name is invalid and the DB does not exist, crashing the application.


## Recommendation

Upgrade to version 3.1.13 or later.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#160</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nconf: Prototype pollution in memory store</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects the package nconf before 0.11.4. When using the memory engine, it is possible to store a nested JSON representation of the configuration. The .set() function, that is responsible for setting the configuration properties, is vulnerable to Prototype Pollution. By providing a crafted property, it is possible to modify the properties on the Object.prototype.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#161</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nconf: Prototype pollution in memory store</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects the package nconf before 0.11.4. When using the memory engine, it is possible to store a nested JSON representation of the configuration. The .set() function, that is responsible for setting the configuration properties, is vulnerable to Prototype Pollution. By providing a crafted property, it is possible to modify the properties on the Object.prototype.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#162</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">path-to-regexp: Backtracking regular expressions cause ReDoS</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">path-to-regexp turns path strings into a regular expressions. In certain cases, path-to-regexp will output a regular expression that can be exploited to cause poor performance. Because JavaScript is single threaded and regex matching runs on the main thread, poor performance will block the event loop and lead to a DoS. The bad regular expression is generated any time you have two parameters within a single segment, separated by something that is not a period (.). For users of 0.1, upgrade to 0.1.10. All other users should upgrade to 8.0.0.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#163</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">path-to-regexp: path-to-regexp Unpatched `path-to-regexp` ReDoS in 0.1.x</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">path-to-regexp turns path strings into a regular expressions. In certain cases, path-to-regexp will output a regular expression that can be exploited to cause poor performance. The regular expression that is vulnerable to backtracking can be generated in the 0.1.x release of path-to-regexp. Upgrade to 0.1.12. This vulnerability exists because of an incomplete fix for CVE-2024-45296.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#164</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">express: &quot;qs&quot; prototype poisoning causes the hang of the node process</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">qs before 6.10.3, as used in Express before 4.17.3 and other products, allows attackers to cause a Node process hang for an Express application because an __ proto__ key can be used. In many typical Express use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as a[__proto__]=b&amp;a[__proto__]&amp;a[length]=100000000. The fix was backported to qs 6.9.7, 6.8.3, 6.7.3, 6.6.1, 6.5.3, 6.4.1, 6.3.3, and 6.2.4 (and therefore Express 4.17.3, which has &quot;deps: qs@6.9.7&quot; in its release description, is not vulnerable).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#165</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">express: &quot;qs&quot; prototype poisoning causes the hang of the node process</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">qs before 6.10.3, as used in Express before 4.17.3 and other products, allows attackers to cause a Node process hang for an Express application because an __ proto__ key can be used. In many typical Express use cases, an unauthenticated remote attacker can place the attack payload in the query string of the URL that is used to visit the application, such as a[__proto__]=b&amp;a[__proto__]&amp;a[length]=100000000. The fix was backported to qs 6.9.7, 6.8.3, 6.7.3, 6.6.1, 6.5.3, 6.4.1, 6.3.3, and 6.2.4 (and therefore Express 4.17.3, which has &quot;deps: qs@6.9.7&quot; in its release description, is not vulnerable).</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#166</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-semver: Regular expression denial of service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Versions of the package semver before 7.5.2 are vulnerable to Regular Expression Denial of Service (ReDoS) via the function new Range, when untrusted user data is provided as a range.


</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#167</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-semver: Regular expression denial of service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Versions of the package semver before 7.5.2 are vulnerable to Regular Expression Denial of Service (ReDoS) via the function new Range, when untrusted user data is provided as a range.


</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#168</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-set-value: type confusion allows bypass of CVE-2019-10747</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects the package set-value before &lt;2.0.1, &gt;=3.0.0 &lt;4.0.1. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the path parameter are arrays.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#169</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-set-value: type confusion allows bypass of CVE-2019-10747</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This affects the package set-value before &lt;2.0.1, &gt;=3.0.0 &lt;4.0.1. A type confusion vulnerability can lead to a bypass of CVE-2019-10747 when the user-provided keys used in the path parameter are arrays.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#170</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary local file read vulnerability during template rendering </div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Directory traversal vulnerability in swig-templates thru 2.0.4 and swig thru 1.4.2, allows attackers to read arbitrary files via the include or extends tags.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="trivy">
        <div class="timeline-rail">
          <div class="timeline-dot sev-high"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#171</span>
            <span class="tool-badge">TRIVY</span>
            <span class="sev-pill sev-high">high</span>
            <span class="location"><code>Node.js:</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">nodejs-y18n: prototype pollution vulnerability</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The package y18n before 3.2.2, 4.0.1 and 5.0.5, is vulnerable to Prototype Pollution.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#172</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) via the cookie `name`, `path`, or `domain`, which can be used to set unexpected values to other cookie fields.

## Workaround
Users who are not able to upgrade to the fixed version should avoid passing untrusted or arbitrary values for the cookie fields and ensure they are set by the application instead of user input.
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `cookie` to version 0.7.0 or higher.
## References
- [GitHub Commit](https://github.com/jshttp/cookie/commit/e10042845354fea83bd8f34af72475eed1dadf5c)
- [GitHub PR](https://github.com/jshttp/cookie/pull/167)
- [Red Hat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2316549)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#173</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) via the cookie `name`, `path`, or `domain`, which can be used to set unexpected values to other cookie fields.

## Workaround
Users who are not able to upgrade to the fixed version should avoid passing untrusted or arbitrary values for the cookie fields and ensure they are set by the application instead of user input.
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `cookie` to version 0.7.0 or higher.
## References
- [GitHub Commit](https://github.com/jshttp/cookie/commit/e10042845354fea83bd8f34af72475eed1dadf5c)
- [GitHub PR](https://github.com/jshttp/cookie/pull/167)
- [Red Hat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2316549)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#174</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Cross-site Scripting (XSS) via the cookie `name`, `path`, or `domain`, which can be used to set unexpected values to other cookie fields.

## Workaround
Users who are not able to upgrade to the fixed version should avoid passing untrusted or arbitrary values for the cookie fields and ensure they are set by the application instead of user input.
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `cookie` to version 0.7.0 or higher.
## References
- [GitHub Commit](https://github.com/jshttp/cookie/commit/e10042845354fea83bd8f34af72475eed1dadf5c)
- [GitHub PR](https://github.com/jshttp/cookie/pull/167)
- [Red Hat Bugzilla Bug](https://bugzilla.redhat.com/show_bug.cgi?id=2316549)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#175</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Open Redirect</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[express](https://github.com/expressjs/express) is a minimalist web framework.

Affected versions of this package are vulnerable to Open Redirect due to the implementation of URL encoding using `encodeurl` before passing it to the `location` header. This can lead to unexpected evaluations of malformed URLs by common redirect allow list implementations in applications, allowing an attacker to bypass a properly implemented allow list and redirect users to malicious sites.
## Remediation
Upgrade `express` to version 4.19.2, 5.0.0-beta.3 or higher.
## References
- [Github Commit](https://github.com/expressjs/express/commit/0b746953c4bd8e377123527db11f9cd866e39f94)
- [GitHub Commit](https://github.com/expressjs/express/commit/0867302ddbde0e9463d0564fea5861feb708c2dd)
- [Github Issue](https://github.com/koajs/koa/issues/1800)
- [GitHub PR](https://github.com/expressjs/express/pull/5551)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#176</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[express](https://github.com/expressjs/express) is a minimalist web framework.

Affected versions of this package are vulnerable to Cross-site Scripting due to improper handling of user input in the `response.redirect` method. An attacker can execute arbitrary code by passing malicious input to this method.


**Note**

To exploit this vulnerability, the following conditions are required:

1) The attacker should be able to control the input to `response.redirect()`

2) express must not redirect before the template appears

3) the browser must not complete redirection before:

4) the user must click on the link in the template
## Remediation
Upgrade `express` to version 4.20.0, 5.0.0 or higher.
## References
- [GitHub Commit](https://github.com/expressjs/express/commit/54271f69b511fea198471e6ff3400ab805d6b553)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#177</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[glob-parent](https://www.npmjs.com/package/glob-parent) is a package that helps extracting the non-magic parent path from a glob string.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). The `enclosure` regex used to check for strings ending in enclosure containing path separator.

### PoC by Yeting Li
```
var globParent = require(&quot;glob-parent&quot;)
function build_attack(n) {
var ret = &quot;{&quot;
for (var i = 0; i &lt; n; i++) {
ret += &quot;/&quot;
}

return ret;
}

globParent(build_attack(5000));
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `glob-parent` to version 5.1.2 or higher.
## References
- [GitHub PR](https://github.com/gulpjs/glob-parent/pull/36)
- [GitHub Release](https://github.com/gulpjs/glob-parent/releases/tag/v5.1.2)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#178</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Configuration Override</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[helmet-csp](https://www.npmjs.com/package/helmet-csp) is a Content Security Policy that helps prevent unwanted content being injected into your webpages.

Affected versions of this package are vulnerable to Configuration Override affecting the application&#x27;s Content Security Policy (CSP). It&#x27;s browser sniffing for Firefox deletes the `default-src` CSP policy, which is the fallback policy. This allows an attacker to remove an application&#x27;s default CSP.
## Remediation
Upgrade `helmet-csp` to version 2.9.2 or higher.
## References
- [GitHub Commit](https://github.com/helmetjs/csp/commit/67a69baafa8198a154f0505a0cf0875f76f6186a)
- [NPM Security Advisory](https://www.npmjs.com/advisories/1176)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#179</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[i](https://www.npmjs.com/package/i) is a custom inflections for nodejs.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `classify` and `underscore` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `i` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/pksunkara/inflect/commit/a9a0a8e9561c3487854c7cae42565d9652ec858b)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#180</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[i](https://www.npmjs.com/package/i) is a custom inflections for nodejs.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `classify` and `underscore` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `i` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/pksunkara/inflect/commit/a9a0a8e9561c3487854c7cae42565d9652ec858b)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#181</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[i](https://www.npmjs.com/package/i) is a custom inflections for nodejs.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `classify` and `underscore` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `i` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/pksunkara/inflect/commit/a9a0a8e9561c3487854c7cae42565d9652ec858b)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#182</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[i](https://www.npmjs.com/package/i) is a custom inflections for nodejs.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `classify` and `underscore` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `i` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/pksunkara/inflect/commit/a9a0a8e9561c3487854c7cae42565d9652ec858b)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#183</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[i](https://www.npmjs.com/package/i) is a custom inflections for nodejs.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `classify` and `underscore` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `i` to version 0.3.7 or higher.
## References
- [GitHub Commit](https://github.com/pksunkara/inflect/commit/a9a0a8e9561c3487854c7cae42565d9652ec858b)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#184</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#185</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#186</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#187</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#188</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#189</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Missing Release of Resource after Effective Lifetime</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Missing Release of Resource after Effective Lifetime via the `makeres` function due to improperly deleting keys from the `reqs` object after execution of callbacks. This behavior causes the keys to remain in the `reqs` object, which leads to resource exhaustion.

Exploiting this vulnerability results in crashing the `node` process or in the application crash.

**Note:**
This library is not maintained, and currently, there is no fix for this issue. To overcome this vulnerability, several dependent packages have eliminated the use of this library.

To trigger the memory leak, an attacker would need to have the ability to execute or influence the asynchronous operations that use the inflight module within the application. This typically requires access to the internal workings of the server or application, which is not commonly exposed to remote users. Therefore, â€œAttack vectorâ€ is marked as â€œLocalâ€.
## PoC
```js
const inflight = require(&#x27;inflight&#x27;);

function testInflight() {
  let i = 0;
  function scheduleNext() {
    let key = `key-${i++}`;
    const callback = () =&gt; {
    };
    for (let j = 0; j &lt; 1000000; j++) {
      inflight(key, callback);
    }

    setImmediate(scheduleNext);
  }


  if (i % 100 === 0) {
    console.log(process.memoryUsage());
  }

  scheduleNext();
}

testInflight();
```
## Remediation
There is no fixed version for `inflight`.
## References
- [GitHub Issue](https://github.com/isaacs/inflight/issues/5)
- [GitHub PR](https://github.com/logdna/logdna-agent/pull/157)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#190</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). The `inline.text regex` may take quadratic time to scan for potential email addresses starting at every point.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 0.6.2 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/commit/00f1f7a23916ef27186d0904635aa3509af63d47)
- [GitHub Commit](https://github.com/markedjs/marked/pull/1460/commits/be27472a8169dda7875330939f8115ab677cdc07)
- [GitHub PR](https://github.com/markedjs/marked/pull/1460)
- [NPM Security Advisory](https://www.npmjs.com/advisories/812)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#191</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when passing unsanitized user input to `inline.reflinkSearch`, if it is not being parsed by a time-limited worker thread.

## PoC
```js
import * as marked from &#x27;marked&#x27;;

console.log(marked.parse(`[x]: x

\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](\\[\\](`));
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 4.0.10 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/commit/c4a3ccd344b6929afa8a1d50ac54a721e57012c0)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#192</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when unsanitized user input is passed to `block.def`.

## PoC
```js
import * as marked from &quot;marked&quot;;
marked.parse(`[x]:${&#x27; &#x27;.repeat(1500)}x ${&#x27; &#x27;.repeat(1500)} x`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 4.0.10 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/commit/c4a3ccd344b6929afa8a1d50ac54a721e57012c0)
- [GitHub Release](https://github.com/markedjs/marked/releases/tag/v4.0.10)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#193</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). A  Denial of Service condition could be triggered through exploitation of the `heading` regex.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 0.4.0 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/commit/09afabf69c6d0c919c03443f47bdfe476566105d)
- [GitHub PR](https://github.com/markedjs/marked/pull/1224)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#194</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). The `em` regex within `src/rules.js` file have multiple unused capture groups which could lead to a denial of service attack if user input is reachable.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `marked` to version 1.1.1 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/commit/bd4f8c464befad2b304d51e33e89e567326e62e0)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#195</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting (XSS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[marked](https://marked.js.org/) is a low-level compiler for parsing markdown without caching or blocking for long periods of time.

Affected versions of this package are vulnerable to Cross-site Scripting (XSS). When mangling is disabled via option `mangle`, marked doesn&#x27;t escape target `href`. This may allow an attacker to inject arbitrary `html-event` into resulting a tag.

For example:
```js
var marked = require(&#x27;marked&#x27;);
marked.setOptions({
  renderer: new marked.Renderer(),
  sanitize: true,
  mangle: false
});

text = `
&lt;bar&quot;onclick=&quot;alert(&#x27;XSS&#x27;)&quot;@foo&gt;
`;

console.log(marked(text));
```

will render:

```html
&lt;p&gt;&lt;a href=&quot;mailto:bar&quot;onclick=&quot;alert(&#x27;XSS&#x27;)&quot;@foo&quot;&gt;bar&quot;onclick=&quot;alert(&#x27;XSS&#x27;)&quot;@foo&lt;/a&gt;&lt;/p&gt;
```
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `marked` to version 0.3.9 or higher.
## References
- [GitHub Commit](https://github.com/markedjs/marked/pull/976/commits/cb72584c5d9d32ebfdbb99e35fb9b81af2b79686)
- [GitHub Issue](https://github.com/chjj/marked/issues/926)
- [GitHub PR](https://github.com/chjj/marked/pull/958)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#196</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Inefficient Regular Expression Complexity</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Inefficient Regular Expression Complexity due to the use of unsafe pattern configurations that allow greedy matching through the `micromatch.braces()` function. An attacker can cause the application to hang or slow down by passing a malicious payload that triggers extensive backtracking in regular expression processing.
## Remediation
Upgrade `micromatch` to version 4.0.8 or higher.
## References
- [GitHub Commit](https://github.com/micromatch/micromatch/commit/500d5d6f42f0e8dfa1cb5464c6cb420b1b6aaaa0)
- [GitHub Issue](https://github.com/micromatch/micromatch/issues/243)
- [GitHub PR](https://github.com/micromatch/micromatch/pull/266)
- [Vulnerable Code](https://github.com/micromatch/micromatch/blob/2c56a8604b68c1099e7bc0f807ce0865a339747a/index.js#L448)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#197</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Inefficient Regular Expression Complexity</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Inefficient Regular Expression Complexity due to the use of unsafe pattern configurations that allow greedy matching through the `micromatch.braces()` function. An attacker can cause the application to hang or slow down by passing a malicious payload that triggers extensive backtracking in regular expression processing.
## Remediation
Upgrade `micromatch` to version 4.0.8 or higher.
## References
- [GitHub Commit](https://github.com/micromatch/micromatch/commit/500d5d6f42f0e8dfa1cb5464c6cb420b1b6aaaa0)
- [GitHub Issue](https://github.com/micromatch/micromatch/issues/243)
- [GitHub PR](https://github.com/micromatch/micromatch/pull/266)
- [Vulnerable Code](https://github.com/micromatch/micromatch/blob/2c56a8604b68c1099e7bc0f807ce0865a339747a/index.js#L448)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#198</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#199</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#200</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#201</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#202</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#203</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#204</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#205</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimatch](https://www.npmjs.com/package/minimatch) is a minimal matching utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `braceExpand` function in `minimatch.js`.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `minimatch` to version 3.0.5 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/minimatch/commit/a8763f4388e51956be62dc6025cec1126beeb5e6)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#206</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#207</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#208</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#209</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#210</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#211</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#212</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#213</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#214</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#215</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#216</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#217</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#218</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#219</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution. The library could be tricked into adding or modifying properties of `Object.prototype` using a `constructor` or `__proto__` payload.

## PoC by Snyk
```
require(&#x27;minimist&#x27;)(&#x27;--__proto__.injected0 value0&#x27;.split(&#x27; &#x27;));
console.log(({}).injected0 === &#x27;value0&#x27;); // true

require(&#x27;minimist&#x27;)(&#x27;--constructor.prototype.injected1 value1&#x27;.split(&#x27; &#x27;));
console.log(({}).injected1 === &#x27;value1&#x27;); // true
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.1, 1.2.3 or higher.
## References
- [Command Injection PoC](https://gist.github.com/Kirill89/47feb345b09bf081317f08dd43403a8a)
- [GitHub Fix Commit #1](https://github.com/substack/minimist/commit/63e7ed05aa4b1889ec2f3b196426db4500cbda94)
- [GitHub Fix Commit #2](https://github.com/substack/minimist/commit/38a4d1caead72ef99e824bb420a2528eec03d9ab)
- [Snyk Research Blog](https://snyk.io/blog/prototype-pollution-minimist/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#220</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Improper Handling of Unexpected Data Type</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Improper Handling of Unexpected Data Type via the `response.writeHead` function. An attacker can manipulate HTTP response headers by passing an array to this function, potentially leading to unintended disclosure or modification of header information.

## Workaround

This vulnerability can be mitigated by passing an object to `response.writeHead()` instead of an array.
## Remediation
Upgrade `on-headers` to version 1.1.0 or higher.
## References
- [GitHub Commit](https://github.com/jshttp/on-headers/commit/c6e384908c9c6127d18831d16ab0bd96e1231867)
- [GitHub Issue](https://github.com/expressjs/morgan/issues/315)
- [GitHub Issue](https://github.com/jshttp/on-headers/issues/15)
- [OpenJS Advisories](https://cna.openjsf.org/security-advisories.html)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#221</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when including multiple regular expression parameters in a single segment, which will produce the regular expression `/^\/([^\/]+?)-([^\/]+?)\/?$/`, if two parameters within a single segment are separated by a character other than a `/` or `.`. Poor performance will block the event loop and can lead to a DoS.

**Note:**
While the 8.0.0 release has completely eliminated the vulnerable functionality, prior versions that have received the patch to mitigate backtracking may still be vulnerable if custom regular expressions are used. So it is strongly recommended for regular expression input to be controlled to avoid malicious performance degradation in those versions. This behavior is enforced as of version 7.1.0 via the `strict` option, which returns an error if a dangerous regular expression is detected.

## Workaround
This vulnerability can be avoided by using a custom regular expression for parameters after the first in a segment, which excludes `-` and `/`.
## PoC
```js
/a${&#x27;-a&#x27;.repeat(8_000)}/a
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `path-to-regexp` to version 0.1.10, 1.9.0, 3.3.0, 6.3.0, 8.0.0 or higher.
## References
- [GitHub Commit](https://github.com/pillarjs/path-to-regexp/commit/29b96b4a1de52824e1ca0f49a701183cc4ed476f)
- [GitHub Commit](https://github.com/pillarjs/path-to-regexp/commit/60f2121e9b66b7b622cc01080df0aabda9eedee6)
- [GitHub Commit](https://github.com/pillarjs/path-to-regexp/commit/f73ec6c86b06f544b977119c2b62a16de480a6a9)
- [Strict Mode Release Note](https://github.com/pillarjs/path-to-regexp/releases/tag/v7.1.0)
- [Vulnerability Write-up](https://blakeembrey.com/posts/2024-09-web-redos/)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#222</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) when including multiple regular expression parameters in a single segment, when the separator is not `.` (e.g. no `/:a-:b`). Poor performance will block the event loop and can lead to a DoS.

**Note:**

This issue is caused due to an incomplete fix for [CVE-2024-45296](https://security.snyk.io/vuln/SNYK-JS-PATHTOREGEXP-7925106).

## Workarounds

This can be mitigated by avoiding using two parameters within a single path segment, when the separator is not `.` (e.g. no `/:a-:b`). Alternatively, the regex used for both parameters can be defined to ensure they do not overlap to allow backtracking.
## PoC
```js
/a${&#x27;-a&#x27;.repeat(8_000)}/a
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `path-to-regexp` to version 0.1.12 or higher.
## References
- [Blog Post](https://blakeembrey.com/posts/2024-09-web-redos)
- [GitHub Commit](https://github.com/pillarjs/path-to-regexp/commit/f01c26a013b1889f0c217c643964513acf17f6a4)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#223</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uncontrolled Resource Consumption (&#x27;Resource Exhaustion&#x27;)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Uncontrolled Resource Consumption (&#x27;Resource Exhaustion&#x27;) due to the lack of folders count validation during the folder creation process. An attacker who generates a large number of sub-folders can consume memory on the system running the software and even crash the client within few seconds of running it using a path with too many sub-folders inside.
## Remediation
Upgrade `tar` to version 6.2.1 or higher.
## References
- [GitHub Commit](https://github.com/isaacs/node-tar/commit/fe8cd57da5686f8695415414bda49206a545f7f7)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#224</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[uglify-js](http://npmjs.com/package/uglify-js) is a JavaScript parser, minifier, compressor and beautifier toolkit.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) via the `string_template` and the `decode_template` functions.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `uglify-js` to version 3.14.3 or higher.
## References
- [GitHub Commit](https://github.com/mishoo/UglifyJS/commit/157521066fc43cff2feab7ffc1ecea603617606b)
- [GitHub Issue](https://github.com/mishoo/UglifyJS/issues/5133)
- [GitHub PR](https://github.com/mishoo/UglifyJS/pull/5134)
- [GitHub PR](https://github.com/mishoo/UglifyJS/pull/5135)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#225</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
The `parse()` function in the [`uglify-js`](https://www.npmjs.com/package/uglify-js) package prior to version 2.6.0 is vulnerable to regular expression denial of service (ReDoS) attacks when long inputs of certain patterns are processed.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade to version `2.6.0` or greater.
If a direct dependency update is not possible, use `snyk wizard` to patch this vulnerability.

## References
- [OWASP - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS)</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-medium"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#226</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-medium">medium</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Arbitrary Code Injection</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[underscore](https://www.npmjs.org/package/underscore) is a JavaScript&#x27;s functional programming helper library.

Affected versions of this package are vulnerable to Arbitrary Code Injection via the `template` function, particularly when the `variable` option is taken from `_.templateSettings` as it is not sanitized.

### PoC
```
const _ = require(&#x27;underscore&#x27;);
_.templateSettings.variable = &quot;a = this.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;touch HELLO&#x27;)&quot;;
const t = _.template(&quot;&quot;)();
```
## Remediation
Upgrade `underscore` to version 1.13.0-2, 1.12.1 or higher.
## References
- [GitHub Additional Information](https://github.com/jashkenas/underscore/blob/cb5f6fc6c2400649d942f1e36f9e5191fb7a1bf1/modules/template.js#L71)
- [GitHub Commit](https://github.com/jashkenas/underscore/commit/4c73526d43838ad6ab43a6134728776632adeb66)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#227</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#228</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#229</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#230</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#231</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#232</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#233</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#234</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[brace-expansion](https://github.com/juliangruber/brace-expansion) is a Brace expansion as known from sh/bash

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the `expand()` function, which is prone to catastrophic backtracking on very long malicious inputs.
## PoC
```js
import index from &quot;./index.js&quot;;

let str = &quot;{a}&quot; + &quot;,&quot;.repeat(100000) + &quot;\u0000&quot;;

let startTime = performance.now();

const result = index(str);

let endTime = performance.now();

let timeTaken = endTime - startTime;

console.log(`åŒ¹é…è€—æ—¶: ${timeTaken.toFixed(3)} æ¯«ç§’`);
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `brace-expansion` to version 1.1.12, 2.0.2, 3.0.1, 4.0.1 or higher.
## References
- [GitHub Advisory](https://github.com/advisories/GHSA-v6h2-p8h4-qcjw)
- [GitHub Commit](https://github.com/juliangruber/brace-expansion/commit/0b6a9781e18e9d2769bb2931f4856d1360243ed2)
- [GitHub Gist](https://gist.github.com/mmmsssttt404/37a40ce7d6e5ca604858fe30814d9466)
- [GitHub PR](https://github.com/juliangruber/brace-expansion/pull/65)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#235</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#236</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#237</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#238</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#239</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#240</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#241</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#242</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#243</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#244</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#245</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#246</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#247</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#248</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#249</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#250</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#251</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#252</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#253</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#254</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#255</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#256</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#257</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#258</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#259</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#260</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#261</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#262</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#263</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#264</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#265</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#266</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#267</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#268</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#269</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#270</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#271</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#272</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#273</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#274</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#275</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#276</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#277</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#278</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#279</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#280</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#281</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#282</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#283</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#284</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#285</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#286</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#287</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#288</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#289</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#290</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#291</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#292</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#293</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#294</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#295</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#296</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#297</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#298</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#299</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#300</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#301</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#302</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#303</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#304</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#305</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#306</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#307</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#308</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#309</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#310</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#311</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#312</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#313</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#314</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#315</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#316</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#317</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#318</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#319</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#320</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#321</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#322</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#323</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#324</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#325</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#326</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#327</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#328</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#329</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#330</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#331</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Validation Bypass</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[kind-of](https://github.com/jonschlinkert/kind-of) is a package that gets the native type of a value.

Affected versions of this package are vulnerable to Validation Bypass. It leverages the built-in constructor of unsafe user-input to detect type information. However, a crafted payload can overwrite this built in attribute to manipulate the type detection result.

## PoC by Feng Xiao
```
var kindOf = require(&#x27;kind-of&#x27;);


var user_input = {
  user: &#x27;barney&#x27;,
  age: 36,
  active: true,
  &quot;constructor&quot;:{&quot;name&quot;:&quot;Symbol&quot;}
};
console.log(kindOf(user_input));
```
## Remediation
Upgrade `kind-of` to version 6.0.3 or higher.
## References
- [GitHub Issue](https://github.com/jonschlinkert/kind-of/issues/30)
- [GitHub PR](https://github.com/jonschlinkert/kind-of/pull/31)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#332</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#333</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#334</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#335</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#336</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#337</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#338</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#339</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#340</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#341</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#342</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#343</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#344</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#345</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#346</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Prototype Pollution</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[minimist](https://www.npmjs.com/package/minimist) is a parse argument options module.

Affected versions of this package are vulnerable to Prototype Pollution due to a missing handler to `Function.prototype`.

**Notes:** 

- This vulnerability is a bypass to [CVE-2020-7598](https://security.snyk.io/vuln/SNYK-JS-MINIMIST-559764)

- The reason for the different CVSS between CVE-2021-44906 to CVE-2020-7598, is that CVE-2020-7598 can pollute objects, while CVE-2021-44906 can pollute only function.


## PoC by Snyk
```js
require(&#x27;minimist&#x27;)(&#x27;--_.constructor.constructor.prototype.foo bar&#x27;.split(&#x27; &#x27;));
console.log((function(){}).foo); // bar
```

## Details

Prototype Pollution is a vulnerability affecting JavaScript. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. JavaScript allows all Object attributes to be altered, including their magical attributes such as `__proto__`, `constructor` and `prototype`. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values.  Properties on the `Object.prototype` are then inherited by all the JavaScript objects through the prototype chain. When that happens, this leads to either denial of service by triggering JavaScript exceptions, or it tampers with the application source code to force the code path that the attacker injects, thereby leading to remote code execution.

There are two main ways in which the pollution of prototypes occurs:

-   Unsafe `Object` recursive merge
    
-   Property definition by path
    

### Unsafe Object recursive merge

The logic of a vulnerable recursive merge function follows the following high-level model:
```
merge (target, source)

  foreach property of source

    if property exists and is an object on both the target and the source

      merge(target[property], source[property])

    else

      target[property] = source[property]
```
&lt;br&gt;  

When the source object contains a property named `__proto__` defined with `Object.defineProperty()` , the condition that checks if the property exists and is an object on both the target and the source passes and the merge recurses with the target, being the prototype of `Object` and the source of `Object` as defined by the attacker. Properties are then copied on the `Object` prototype.

Clone operations are a special sub-class of unsafe recursive merges, which occur when a recursive merge is conducted on an empty object: `merge({},source)`.

`lodash` and `Hoek` are examples of libraries susceptible to recursive merge attacks.

### Property definition by path

There are a few JavaScript libraries that use an API to define property values on an object based on a given path. The function that is generally affected contains this signature: `theFunction(object, path, value)`

If the attacker can control the value of â€œpathâ€, they can set this value to `__proto__.myValue`. `myValue` is then assigned to the prototype of the class of the object.

## Types of attacks

There are a few methods by which Prototype Pollution can be manipulated:

| Type |Origin  |Short description |
|--|--|--|
| **Denial of service (DoS)**|Client  |This is the most likely attack. &lt;br&gt;DoS occurs when `Object` holds generic functions that are implicitly called for various operations (for example, `toString` and `valueOf`). &lt;br&gt; The attacker pollutes `Object.prototype.someattr` and alters its state to an unexpected value such as `Int` or `Object`. In this case, the code fails and is likely to cause a denial of service.  &lt;br&gt;**For example:** if an attacker pollutes `Object.prototype.toString` by defining it as an integer, if the codebase at any point was reliant on `someobject.toString()` it would fail. |
 |**Remote Code Execution**|Client|Remote code execution is generally only possible in cases where the codebase evaluates a specific attribute of an object, and then executes that evaluation.&lt;br&gt;**For example:** `eval(someobject.someattr)`. In this case, if the attacker pollutes `Object.prototype.someattr` they are likely to be able to leverage this in order to execute code.|
|**Property Injection**|Client|The attacker pollutes properties that the codebase relies on for their informative value, including security properties such as cookies or tokens.&lt;br&gt;  **For example:** if a codebase checks privileges for `someuser.isAdmin`, then when the attacker pollutes `Object.prototype.isAdmin` and sets it to equal `true`, they can then achieve admin privileges.|

## Affected environments

The following environments are susceptible to a Prototype Pollution attack:

-   Application server
    
-   Web server

-   Web browser
    

## How to prevent

1.  Freeze the prototypeâ€” use `Object.freeze (Object.prototype)`.
    
2.  Require schema validation of JSON input.
    
3.  Avoid using unsafe recursive merge functions.
    
4.  Consider using objects without prototypes (for example, `Object.create(null)`), breaking the prototype chain and preventing pollution.
    
5.  As a best practice use `Map` instead of `Object`.

### For more information on this vulnerability type:

[Arteau, Oliver. â€œJavaScript prototype pollution attack in NodeJS application.â€ GitHub, 26 May 2018](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)

## Remediation
Upgrade `minimist` to version 0.2.4, 1.2.6 or higher.
## References
- [Fix Commit](https://github.com/minimistjs/minimist/commit/34e20b8461118608703d6485326abbb8e35e1703)
- [Fix Commit](https://github.com/minimistjs/minimist/commit/c2b981977fa834b223b408cfb860f933c9811e4d)
- [Vulnerable Code](https://github.com/minimistjs/minimist/blob/master/index.js#L69)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#347</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[send](https://github.com/pillarjs/send) is a Better streaming static file server with Range and conditional-GET support

Affected versions of this package are vulnerable to Cross-site Scripting due to improper user input sanitization passed to the `SendStream.redirect()` function, which executes untrusted code. An attacker can execute arbitrary code by manipulating the input parameters to this method.

**Note:**

Exploiting this vulnerability requires the following:

1) The attacker needs to control the input to `response.redirect()`

2) Express MUST NOT redirect before the template appears

3) The browser MUST NOT complete redirection before

4) The user MUST click on the link in the template
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `send` to version 0.19.0, 1.1.0 or higher.
## References
- [GitHub Commit](https://github.com/pillarjs/send/commit/ae4f2989491b392ae2ef3b0015a019770ae65d35)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#348</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[send](https://github.com/pillarjs/send) is a Better streaming static file server with Range and conditional-GET support

Affected versions of this package are vulnerable to Cross-site Scripting due to improper user input sanitization passed to the `SendStream.redirect()` function, which executes untrusted code. An attacker can execute arbitrary code by manipulating the input parameters to this method.

**Note:**

Exploiting this vulnerability requires the following:

1) The attacker needs to control the input to `response.redirect()`

2) Express MUST NOT redirect before the template appears

3) The browser MUST NOT complete redirection before

4) The user MUST click on the link in the template
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `send` to version 0.19.0, 1.1.0 or higher.
## References
- [GitHub Commit](https://github.com/pillarjs/send/commit/ae4f2989491b392ae2ef3b0015a019770ae65d35)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#349</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Cross-site Scripting</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[serve-static](https://github.com/expressjs/serve-static) is a server.

Affected versions of this package are vulnerable to Cross-site Scripting due to improper sanitization of user input in the `redirect` function. An attacker can manipulate the redirection process by injecting malicious code into the input. 


**Note**

To exploit this vulnerability, the following conditions are required:

1) The attacker should be able to control the input to `response.redirect()`

2) express must not redirect before the template appears

3) the browser must not complete redirection before:

4) the user must click on the link in the template
## Details

Cross-site scripting (or XSS) is a code vulnerability that occurs when an attacker â€œinjectsâ€ a malicious script into an otherwise trusted website. The injected script gets downloaded and executed by the end userâ€™s browser when the user interacts with the compromised website.

This is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browserâ€™s Same Origin Policy.

Injecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.

Escaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `&lt;` can be coded as  `&amp;lt`; and `&gt;` can be coded as `&amp;gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `&lt;` and `&gt;` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if theyâ€™ve been correctly escaped in the application code and in this way the attempted attack is diverted.
 
The most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. 

### Types of attacks
There are a few methods by which XSS can be manipulated:

|Type|Origin|Description|
|--|--|--|
|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|
|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the userâ€™s browser.| 
|**DOM-based**|Client|The attacker forces the userâ€™s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|
|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|

### Affected environments
The following environments are susceptible to an XSS attack:

* Web servers
* Application servers
* Web application environments

### How to prevent
This section describes the top best practices designed to specifically protect your code: 

* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. 
* Convert special characters such as `?`, `&amp;`, `/`, `&lt;`, `&gt;` and spaces to their respective HTML or URL encoded equivalents. 
* Give users the option to disable client-side scripts.
* Redirect invalid requests.
* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.
* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.
* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.

## Remediation
Upgrade `serve-static` to version 1.16.0, 2.1.0 or higher.
## References
- [GitHub Commit](https://github.com/expressjs/serve-static/commit/0c11fad159898cdc69fd9ab63269b72468ecaf6b)
- [GitHub Commit](https://github.com/expressjs/serve-static/commit/ce730896fddce1588111d9ef6fdf20896de5c6fa)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#350</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[tar](https://www.npmjs.com/package/tar) is a full-featured Tar for Node.js.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS). When stripping the trailing slash from `files` arguments, the  `f.replace(/\/+$/, &#x27;&#x27;)` performance of this function can exponentially degrade when `f` contains many `/` characters resulting in ReDoS. 

This vulnerability is not likely to be exploitable as it requires that the untrusted input is being passed into the `tar.extract()` or `tar.list()` array of entries to parse/extract, which would be unusual.

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `tar` to version 6.1.4, 5.0.8, 4.4.16 or higher.
## References
- [GitHub Commit](https://github.com/npm/node-tar/commit/06cbde5935aa7643f578f874de84a7da2a74fe3a)
- [GitHub Commit](https://github.com/npm/node-tar/commit/adf35115dbc6e7a479fe3c38f859baf6ffff7a7a)
- [GitHub Commit](https://github.com/npm/node-tar/commit/d3d5a4e4560f18131e64fc62f5a281b238ef2ecf)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#351</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uninitialized Memory Exposure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://www.npmjs.com/package/utile) is a drop-in replacement for util with some additional advantageous functions.

Affected versions of this package are vulnerable to Uninitialized Memory Exposure. A malicious user could extract sensitive data from uninitialized memory or to cause a DoS by passing in a large number, in setups where typed user input can be passed.

**Note** Uninitialized Memory Exposure impacts only Node.js 6.x or lower, Denial of Service impacts any Node.js version.

## Details
The Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.
```js
const buf1 = new Buffer([1,2,3]);
// creates a buffer containing [01, 02, 03]
const buf2 = new Buffer(&#x27;test&#x27;);
// creates a buffer containing ASCII bytes [74, 65, 73, 74]
const buf3 = new Buffer(10);
// creates a buffer of length 10
```

The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.
When using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.


## Remediation
There is no fix version for `utile`.

## References
- [HackerOne Report](https://hackerone.com/reports/321701)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#352</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uninitialized Memory Exposure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://www.npmjs.com/package/utile) is a drop-in replacement for util with some additional advantageous functions.

Affected versions of this package are vulnerable to Uninitialized Memory Exposure. A malicious user could extract sensitive data from uninitialized memory or to cause a DoS by passing in a large number, in setups where typed user input can be passed.

**Note** Uninitialized Memory Exposure impacts only Node.js 6.x or lower, Denial of Service impacts any Node.js version.

## Details
The Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.
```js
const buf1 = new Buffer([1,2,3]);
// creates a buffer containing [01, 02, 03]
const buf2 = new Buffer(&#x27;test&#x27;);
// creates a buffer containing ASCII bytes [74, 65, 73, 74]
const buf3 = new Buffer(10);
// creates a buffer of length 10
```

The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.
When using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.


## Remediation
There is no fix version for `utile`.

## References
- [HackerOne Report](https://hackerone.com/reports/321701)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#353</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uninitialized Memory Exposure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://www.npmjs.com/package/utile) is a drop-in replacement for util with some additional advantageous functions.

Affected versions of this package are vulnerable to Uninitialized Memory Exposure. A malicious user could extract sensitive data from uninitialized memory or to cause a DoS by passing in a large number, in setups where typed user input can be passed.

**Note** Uninitialized Memory Exposure impacts only Node.js 6.x or lower, Denial of Service impacts any Node.js version.

## Details
The Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.
```js
const buf1 = new Buffer([1,2,3]);
// creates a buffer containing [01, 02, 03]
const buf2 = new Buffer(&#x27;test&#x27;);
// creates a buffer containing ASCII bytes [74, 65, 73, 74]
const buf3 = new Buffer(10);
// creates a buffer of length 10
```

The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.
When using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.


## Remediation
There is no fix version for `utile`.

## References
- [HackerOne Report](https://hackerone.com/reports/321701)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#354</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uninitialized Memory Exposure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://www.npmjs.com/package/utile) is a drop-in replacement for util with some additional advantageous functions.

Affected versions of this package are vulnerable to Uninitialized Memory Exposure. A malicious user could extract sensitive data from uninitialized memory or to cause a DoS by passing in a large number, in setups where typed user input can be passed.

**Note** Uninitialized Memory Exposure impacts only Node.js 6.x or lower, Denial of Service impacts any Node.js version.

## Details
The Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.
```js
const buf1 = new Buffer([1,2,3]);
// creates a buffer containing [01, 02, 03]
const buf2 = new Buffer(&#x27;test&#x27;);
// creates a buffer containing ASCII bytes [74, 65, 73, 74]
const buf3 = new Buffer(10);
// creates a buffer of length 10
```

The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.
When using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.


## Remediation
There is no fix version for `utile`.

## References
- [HackerOne Report](https://hackerone.com/reports/321701)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#355</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Uninitialized Memory Exposure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[utile](https://www.npmjs.com/package/utile) is a drop-in replacement for util with some additional advantageous functions.

Affected versions of this package are vulnerable to Uninitialized Memory Exposure. A malicious user could extract sensitive data from uninitialized memory or to cause a DoS by passing in a large number, in setups where typed user input can be passed.

**Note** Uninitialized Memory Exposure impacts only Node.js 6.x or lower, Denial of Service impacts any Node.js version.

## Details
The Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.
```js
const buf1 = new Buffer([1,2,3]);
// creates a buffer containing [01, 02, 03]
const buf2 = new Buffer(&#x27;test&#x27;);
// creates a buffer containing ASCII bytes [74, 65, 73, 74]
const buf3 = new Buffer(10);
// creates a buffer of length 10
```

The first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.
When using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.


## Remediation
There is no fix version for `utile`.

## References
- [HackerOne Report](https://hackerone.com/reports/321701)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#356</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[debug](https://github.com/visionmedia/debug) is a small debugging utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the function `useColors` via manipulation of the `str` argument. 
The vulnerability can cause a very low impact of about 2 seconds of matching time for data 50k characters long.

**Note:**
CVE-2017-20165 is a duplicate of this vulnerability.

## PoC

Use the following regex in the `%o` formatter.
```js
/\s*\n\s*/
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `debug` to version 2.6.9, 3.1.0, 3.2.7, 4.3.1 or higher.
## References
- [GitHub Commit](https://github.com/debug-js/debug/commit/b6d12fdbc63b483e5c969da33ea6adc09946b5ac)
- [GitHub Commit](https://github.com/visionmedia/debug/pull/504/commits/42a6ae0737f9243c80b6d3dbb08a69a7ae2a1061)
- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)
- [GitHub PR](https://github.com/visionmedia/debug/pull/504)
- [GitHub Release Notes 2.6.9](https://github.com/debug-js/debug/releases/tag/2.6.9)
- [GitHub Release Notes 3.1.0](https://github.com/debug-js/debug/releases/tag/3.1.0)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#357</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[debug](https://github.com/visionmedia/debug) is a small debugging utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the function `useColors` via manipulation of the `str` argument. 
The vulnerability can cause a very low impact of about 2 seconds of matching time for data 50k characters long.

**Note:**
CVE-2017-20165 is a duplicate of this vulnerability.

## PoC

Use the following regex in the `%o` formatter.
```js
/\s*\n\s*/
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `debug` to version 2.6.9, 3.1.0, 3.2.7, 4.3.1 or higher.
## References
- [GitHub Commit](https://github.com/debug-js/debug/commit/b6d12fdbc63b483e5c969da33ea6adc09946b5ac)
- [GitHub Commit](https://github.com/visionmedia/debug/pull/504/commits/42a6ae0737f9243c80b6d3dbb08a69a7ae2a1061)
- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)
- [GitHub PR](https://github.com/visionmedia/debug/pull/504)
- [GitHub Release Notes 2.6.9](https://github.com/debug-js/debug/releases/tag/2.6.9)
- [GitHub Release Notes 3.1.0](https://github.com/debug-js/debug/releases/tag/3.1.0)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#358</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[debug](https://github.com/visionmedia/debug) is a small debugging utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) in the function `useColors` via manipulation of the `str` argument. 
The vulnerability can cause a very low impact of about 2 seconds of matching time for data 50k characters long.

**Note:**
CVE-2017-20165 is a duplicate of this vulnerability.

## PoC

Use the following regex in the `%o` formatter.
```js
/\s*\n\s*/
```

## Details

Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.

## Remediation
Upgrade `debug` to version 2.6.9, 3.1.0, 3.2.7, 4.3.1 or higher.
## References
- [GitHub Commit](https://github.com/debug-js/debug/commit/b6d12fdbc63b483e5c969da33ea6adc09946b5ac)
- [GitHub Commit](https://github.com/visionmedia/debug/pull/504/commits/42a6ae0737f9243c80b6d3dbb08a69a7ae2a1061)
- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)
- [GitHub PR](https://github.com/visionmedia/debug/pull/504)
- [GitHub Release Notes 2.6.9](https://github.com/debug-js/debug/releases/tag/2.6.9)
- [GitHub Release Notes 3.1.0](https://github.com/debug-js/debug/releases/tag/3.1.0)
</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#359</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.

*Proof of concept*
```js
ms = require(&#x27;ms&#x27;);
ms(&#x27;1&#x27;.repeat(9998) + &#x27;Q&#x27;) // Takes about ~0.3s
```

**Note:** Snyk&#x27;s patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.
Based on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.

For more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).

## Disclosure Timeline
- Feb 9th, 2017 - Reported the issue to package owner.
- Feb 11th, 2017 - Issue acknowledged by package owner.
- April 12th, 2017 - Fix PR opened by Snyk Security Team.
- May 15th, 2017 - Vulnerability published.
- May 16th, 2017 - Issue fixed and version `2.0.0` released.
- May 21th, 2017 - Patches released for versions `&gt;=0.7.1, &lt;=1.0.0`.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.


## Remediation
Upgrade `ms` to version 2.0.0 or higher.

## References
- [GitHub PR](https://github.com/zeit/ms/pull/89)
- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="snyk">
        <div class="timeline-rail">
          <div class="timeline-dot sev-low"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#360</span>
            <span class="tool-badge">SNYK</span>
            <span class="sev-pill sev-low">low</span>
            <span class="location"><code></code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">Regular Expression Denial of Service (ReDoS)</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">## Overview
[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.

Affected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.

*Proof of concept*
```js
ms = require(&#x27;ms&#x27;);
ms(&#x27;1&#x27;.repeat(9998) + &#x27;Q&#x27;) // Takes about ~0.3s
```

**Note:** Snyk&#x27;s patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.
Based on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.

For more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).

## Disclosure Timeline
- Feb 9th, 2017 - Reported the issue to package owner.
- Feb 11th, 2017 - Issue acknowledged by package owner.
- April 12th, 2017 - Fix PR opened by Snyk Security Team.
- May 15th, 2017 - Vulnerability published.
- May 16th, 2017 - Issue fixed and version `2.0.0` released.
- May 21th, 2017 - Patches released for versions `&gt;=0.7.1, &lt;=1.0.0`.

## Details
Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.

The Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren&#x27;t very intuitive and can ultimately end up making it easy for attackers to take your site down.

Letâ€™s take the following regular expression as an example:
```js
regex = /A(B|C+)+D/
```

This regular expression accomplishes the following:
- `A` The string must start with the letter &#x27;A&#x27;
- `(B|C+)+` The string must then follow the letter A with either the letter &#x27;B&#x27; or some number of occurrences of the letter &#x27;C&#x27; (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.
- `D` Finally, we ensure this section of the string ends with a &#x27;D&#x27;

The expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`

It most cases, it doesn&#x27;t take very long for a regex engine to find a match:

```bash
$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD&quot;)&#x27;
0.04s user 0.01s system 95% cpu 0.052 total

$ time node -e &#x27;/A(B|C+)+D/.test(&quot;ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX&quot;)&#x27;
1.79s user 0.02s system 99% cpu 1.812 total
```

The entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.

Most Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesnâ€™t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.

Let&#x27;s look at how our expression runs into this problem, using a shorter string: &quot;ACCCX&quot;. While it seems fairly straightforward, there are still four different ways that the engine could match those three C&#x27;s:
1. CCC
2. CC+C
3. C+CC
4. C+C+C.

The engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn&#x27;t match.

From there, the number of steps the engine must use to validate a string just continues to grow.

| String | Number of C&#x27;s | Number of steps |
| -------|-------------:| -----:|
| ACCCX | 3 | 38
| ACCCCX | 4 | 71
| ACCCCCX | 5 | 136
| ACCCCCCCCCCCCCCX | 14 | 65,553


By the time the string includes 14 C&#x27;s, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.


## Remediation
Upgrade `ms` to version 2.0.0 or higher.

## References
- [GitHub PR](https://github.com/zeit/ms/pull/89)
- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-info"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#361</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-info">info</span>
            <span class="location"><code>server.js:15</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">A CSRF middleware was not detected in your express application. Ensure you are either using one such as `csurf` or `csrf` (see rule references) and/or you are properly doing CSRF validation in your routes with a token or cookies.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The flagged line initializes the Express application. The primary vulnerability identified is the absence of CSRF protection middleware, which is crucial for preventing cross-site request forgery attacks in web applications handling state-changing requests.&quot;,
  &quot;fix_suggestion&quot;: &quot;To address this, CSRF protection middleware (like &#x27;csurf&#x27;) should be integrated. This involves requiring the middleware, initializing it, and applying it to the Express app, preferably before routes that modify state.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;const app = express(); // Web framework to handle routing requests&quot;,
    &quot;after&quot;: &quot;const csurf = require(&#x27;csurf&#x27;);\nconst app = express(); // Web framework to handle routing requests\napp.use(session({ secret: cookieSecret, resave: false, saveUninitialized: true }));\napp.use(csurf());&quot;
  },
  &quot;references&quot;: [
    &quot;https://expressjs.com/en/resources.html#middleware&quot;,
    &quot;https://www.npmjs.com/package/csurf&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>        1 | &quot;use strict&quot;;
        2 | 
        3 | const express = require(&quot;express&quot;);
        4 | const favicon = require(&quot;serve-favicon&quot;);
        5 | const bodyParser = require(&quot;body-parser&quot;);
        6 | const session = require(&quot;express-session&quot;);
        7 | // const csrf = require(&#x27;csurf&#x27;);
        8 | const consolidate = require(&quot;consolidate&quot;); // Templating library adapter for Express
        9 | const swig = require(&quot;swig&quot;);
       10 | // const helmet = require(&quot;helmet&quot;);
       11 | const MongoClient = require(&quot;mongodb&quot;).MongoClient; // Driver for connecting to MongoDB
       12 | const http = require(&quot;http&quot;);
       13 | const marked = require(&quot;marked&quot;);
       14 | //const nosniff = require(&#x27;dont-sniff-mimetype&#x27;);
=&gt;     15 | const app = express(); // Web framework to handle routing requests
       16 | const routes = require(&quot;./app/routes&quot;);
       17 | const { port, db, cookieSecret } = require(&quot;./config/config&quot;); // Application config properties
       18 | /*
       19 | // Fix for A6-Sensitive Data Exposure
       20 | // Load keys for establishing secure HTTPS connection
       21 | const fs = require(&quot;fs&quot;);
       22 | const https = require(&quot;https&quot;);
       23 | const path = require(&quot;path&quot;);
       24 | const httpsOptions = {
       25 |     key: fs.readFileSync(path.resolve(__dirname, &quot;./artifacts/cert/server.key&quot;)),
       26 |     cert: fs.readFileSync(path.resolve(__dirname, &quot;./artifacts/cert/server.crt&quot;))
       27 | };
       28 | */
       29 | 
       30 | MongoClient.connect(db, (err, db) =&gt; {
       31 |     if (err) {
       32 |         console.log(&quot;Error: DB: connect&quot;);
       33 |         console.log(err);
       34 |         process.exit(1);
       35 |     }</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#362</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/routes/contributions.js:32</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.browser.security.eval-detected.eval-detected</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used here to parse user-controlled input from `req.body`. This is highly dangerous as it allows arbitrary code execution if an attacker can inject malicious JavaScript code into the `preTax`, `afterTax`, or `roth` fields.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace `eval()` with `parseFloat()` to safely parse the string inputs as floating-point numbers. This prevents code injection and aligns with the intention of numerical input.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const preTax = eval(req.body.preTax);&quot;,
    &quot;after&quot;: &quot;        const preTax = parseFloat(req.body.preTax);\n        const afterTax = parseFloat(req.body.afterTax);\n        const roth = parseFloat(req.body.roth);&quot;
  },
  &quot;references&quot;: [
    &quot;https://owasp.org/www-community/vulnerabilities/Code_injection&quot;,
    &quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       12 |     this.displayContributions = (req, res, next) =&gt; {
       13 |         const {
       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
=&gt;     32 |         const preTax = eval(req.body.preTax);
       33 |         const afterTax = eval(req.body.afterTax);
       34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#363</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>app/routes/contributions.js:32</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.lang.security.audit.code-string-concat.code-string-concat</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Found data from an Express or Next web request flowing to `eval`. If this data is user-controllable this can lead to execution of arbitrary system commands in the context of your application process. Avoid `eval` whenever possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used here to parse user-controlled input from `req.body`. This is highly dangerous as it allows arbitrary code execution if an attacker can inject malicious JavaScript code into the `preTax`, `afterTax`, or `roth` fields.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace `eval()` with `parseFloat()` to safely parse the string inputs as floating-point numbers. This prevents code injection and aligns with the intention of numerical input.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const preTax = eval(req.body.preTax);&quot;,
    &quot;after&quot;: &quot;        const preTax = parseFloat(req.body.preTax);\n        const afterTax = parseFloat(req.body.afterTax);\n        const roth = parseFloat(req.body.roth);&quot;
  },
  &quot;references&quot;: [
    &quot;https://owasp.org/www-community/vulnerabilities/Code_injection&quot;,
    &quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       12 |     this.displayContributions = (req, res, next) =&gt; {
       13 |         const {
       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
=&gt;     32 |         const preTax = eval(req.body.preTax);
       33 |         const afterTax = eval(req.body.afterTax);
       34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#364</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/routes/contributions.js:33</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.browser.security.eval-detected.eval-detected</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used to parse `req.body.afterTax`. Since `req.body` is directly controlled by the user, this opens up a critical code injection vulnerability, allowing attackers to execute arbitrary JavaScript code within the server&#x27;s context.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace the `eval()` call with `parseFloat()` to safely convert the user-provided string to a floating-point number. This prevents code execution while retaining the intended numerical parsing.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const afterTax = eval(req.body.afterTax);&quot;,
    &quot;after&quot;: &quot;        const afterTax = parseFloat(req.body.afterTax);&quot;
  },
  &quot;references&quot;: [
    &quot;https://owasp.org/www-community/attacks/Server_Side_JavaScript_Injection&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       13 |         const {
       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
       32 |         const preTax = eval(req.body.preTax);
=&gt;     33 |         const afterTax = eval(req.body.afterTax);
       34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,
       53 |                 environmentalScripts</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#365</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>app/routes/contributions.js:33</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.lang.security.audit.code-string-concat.code-string-concat</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Found data from an Express or Next web request flowing to `eval`. If this data is user-controllable this can lead to execution of arbitrary system commands in the context of your application process. Avoid `eval` whenever possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used to parse `req.body.afterTax`. Since `req.body` is directly controlled by the user, this opens up a critical code injection vulnerability, allowing attackers to execute arbitrary JavaScript code within the server&#x27;s context.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace the `eval()` call with `parseFloat()` to safely convert the user-provided string to a floating-point number. This prevents code execution while retaining the intended numerical parsing.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const afterTax = eval(req.body.afterTax);&quot;,
    &quot;after&quot;: &quot;        const afterTax = parseFloat(req.body.afterTax);&quot;
  },
  &quot;references&quot;: [
    &quot;https://owasp.org/www-community/attacks/Server_Side_JavaScript_Injection&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       13 |         const {
       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
       32 |         const preTax = eval(req.body.preTax);
=&gt;     33 |         const afterTax = eval(req.body.afterTax);
       34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,
       53 |                 environmentalScripts</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#366</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/routes/contributions.js:34</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.browser.security.eval-detected.eval-detected</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used to parse user-provided input (`req.body.roth`). This is highly dangerous as it allows arbitrary JavaScript code execution, enabling attackers to manipulate application logic or access sensitive data.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace `eval()` with `parseFloat()` or `parseInt()` to safely convert the string input to a number. Input validation should also be performed before use.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const roth = eval(req.body.roth);&quot;,
    &quot;after&quot;: &quot;        const roth = parseFloat(req.body.roth);\n        if (isNaN(roth)) {\n            return res.render(\&quot;contributions\&quot;, { updateError: \&quot;Invalid Roth contribution percentage\&quot;, userId, environmentalScripts });\n        }&quot;
  },
  &quot;references&quot;: [
    &quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;,
    &quot;https://owasp.org/www-community/attacks/xss&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
       32 |         const preTax = eval(req.body.preTax);
       33 |         const afterTax = eval(req.body.afterTax);
=&gt;     34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,
       53 |                 environmentalScripts
       54 |             });</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#367</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>app/routes/contributions.js:34</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.lang.security.audit.code-string-concat.code-string-concat</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Found data from an Express or Next web request flowing to `eval`. If this data is user-controllable this can lead to execution of arbitrary system commands in the context of your application process. Avoid `eval` whenever possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `eval()` function is used to parse user-provided input (`req.body.roth`). This is highly dangerous as it allows arbitrary JavaScript code execution, enabling attackers to manipulate application logic or access sensitive data.&quot;,
  &quot;fix_suggestion&quot;: &quot;Replace `eval()` with `parseFloat()` or `parseInt()` to safely convert the string input to a number. Input validation should also be performed before use.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        const roth = eval(req.body.roth);&quot;,
    &quot;after&quot;: &quot;        const roth = parseFloat(req.body.roth);\n        if (isNaN(roth)) {\n            return res.render(\&quot;contributions\&quot;, { updateError: \&quot;Invalid Roth contribution percentage\&quot;, userId, environmentalScripts });\n        }&quot;
  },
  &quot;references&quot;: [
    &quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;,
    &quot;https://owasp.org/www-community/attacks/xss&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       14 |             userId
       15 |         } = req.session;
       16 | 
       17 |         contributionsDAO.getByUserId(userId, (error, contrib) =&gt; {
       18 |             if (error) return next(error);
       19 | 
       20 |             contrib.userId = userId; //set for nav menu items
       21 |             return res.render(&quot;contributions&quot;, {
       22 |                 ...contrib,
       23 |                 environmentalScripts
       24 |             });
       25 |         });
       26 |     };
       27 | 
       28 |     this.handleContributionsUpdate = (req, res, next) =&gt; {
       29 | 
       30 |         /*jslint evil: true */
       31 |         // Insecure use of eval() to parse inputs
       32 |         const preTax = eval(req.body.preTax);
       33 |         const afterTax = eval(req.body.afterTax);
=&gt;     34 |         const roth = eval(req.body.roth);
       35 | 
       36 |         /*
       37 |         //Fix for A1 -1 SSJS Injection attacks - uses alternate method to eval
       38 |         const preTax = parseInt(req.body.preTax);
       39 |         const afterTax = parseInt(req.body.afterTax);
       40 |         const roth = parseInt(req.body.roth);
       41 |         */
       42 |         const {
       43 |             userId
       44 |         } = req.session;
       45 | 
       46 |         //validate contributions
       47 |         const validations = [isNaN(preTax), isNaN(afterTax), isNaN(roth), preTax &lt; 0, afterTax &lt; 0, roth &lt; 0];
       48 |         const isInvalid = validations.some(validation =&gt; validation);
       49 |         if (isInvalid) {
       50 |             return res.render(&quot;contributions&quot;, {
       51 |                 updateError: &quot;Invalid contribution percentages&quot;,
       52 |                 userId,
       53 |                 environmentalScripts
       54 |             });</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#368</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/routes/index.js:72</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-open-redirect.express-open-redirect</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">The application redirects to a URL specified by user-supplied input `req` that is not validated. This could redirect users to malicious locations. Consider using an allow-list approach to validate URLs, or warn users they are being redirected to a third-party website.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The `res.redirect` function directly uses the `url` query parameter without any validation. This allows an attacker to craft a malicious URL pointing to a phishing site or other harmful destinations, causing an open redirect vulnerability.&quot;,
  &quot;fix_suggestion&quot;: &quot;Implement an allow-list of safe domains to redirect to. If the provided URL is not on the allow-list, redirect to a default safe URL or show an error message.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;        return res.redirect(req.query.url);&quot;,
    &quot;after&quot;: &quot;        const allowedDomains = [&#x27;example.com&#x27;, &#x27;trusted-resource.org&#x27;]; // Define your allowed domains\n        const redirectUrl = req.query.url;\n        const parsedUrl = new URL(redirectUrl, `http://${req.headers.host}`); // Use a base URL for relative paths\n\n        if (allowedDomains.some(domain =&gt; parsedUrl.hostname.includes(domain))) {\n            return res.redirect(redirectUrl);\n        } else {\n            // Redirect to a safe default or show an error\n            return res.redirect(&#x27;/learn&#x27;); // Or res.status(400).send(&#x27;Invalid redirect URL.&#x27;);\n        }&quot;
  },
  &quot;references&quot;: [
    &quot;https://owasp.org/www-community/attacks/Open_redirect&quot;,
    &quot;https://expressjs.com/en/guide/routing.html&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       52 |     app.post(&quot;/contributions&quot;, isLoggedIn, contributionsHandler.handleContributionsUpdate);
       53 | 
       54 |     // Benefits Page
       55 |     app.get(&quot;/benefits&quot;, isLoggedIn, benefitsHandler.displayBenefits);
       56 |     app.post(&quot;/benefits&quot;, isLoggedIn, benefitsHandler.updateBenefits);
       57 |     /* Fix for A7 - checks user role to implement  Function Level Access Control
       58 |      app.get(&quot;/benefits&quot;, isLoggedIn, isAdmin, benefitsHandler.displayBenefits);
       59 |      app.post(&quot;/benefits&quot;, isLoggedIn, isAdmin, benefitsHandler.updateBenefits);
       60 |      */
       61 | 
       62 |     // Allocations Page
       63 |     app.get(&quot;/allocations/:userId&quot;, isLoggedIn, allocationsHandler.displayAllocations);
       64 | 
       65 |     // Memos Page
       66 |     app.get(&quot;/memos&quot;, isLoggedIn, memosHandler.displayMemos);
       67 |     app.post(&quot;/memos&quot;, isLoggedIn, memosHandler.addMemos);
       68 | 
       69 |     // Handle redirect for learning resources link
       70 |     app.get(&quot;/learn&quot;, isLoggedIn, (req, res) =&gt; {
       71 |         // Insecure way to handle redirects by taking redirect url from query string
=&gt;     72 |         return res.redirect(req.query.url);
       73 |     });
       74 | 
       75 |     // Research Page
       76 |     app.get(&quot;/research&quot;, isLoggedIn, researchHandler.displayResearch);
       77 | 
       78 |     // Mount tutorial router
       79 |     app.use(&quot;/tutorial&quot;, tutorialRouter);
       80 | 
       81 |     // Error handling middleware
       82 |     app.use(ErrorHandler);
       83 | };
       84 | 
       85 | module.exports = index;</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#369</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/benefits.html:54</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">python.django.security.django-no-csrf-token.django-no-csrf-token</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The form submission to the `/benefits` endpoint is vulnerable to Cross-Site Request Forgery (CSRF) because it does not include a CSRF token. An attacker could trick a user into submitting this form unintentionally, leading to unauthorized benefit date modifications.&quot;,
  &quot;fix_suggestion&quot;: &quot;Include the `{% csrf_token %}` template tag within the form to generate a CSRF token, which Django&#x27;s CSRF middleware will then validate on submission.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;&lt;form method=\&quot;POST\&quot; action=\&quot;/benefits\&quot;&gt;&quot;,
    &quot;after&quot;: &quot;{% csrf_token %}\n&lt;form method=\&quot;POST\&quot; action=\&quot;/benefits\&quot;&gt;&quot;
  },
  &quot;references&quot;: [
    &quot;https://docs.djangoproject.com/en/stable/ref/csrf/&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       34 | 
       35 |         &lt;div class=&quot;table-responsive&quot;&gt;
       36 |             &lt;table class=&quot;table table-bordered table-hover&quot;&gt;
       37 |                 &lt;thead&gt;
       38 |                     &lt;tr&gt;
       39 |                         &lt;th class=&quot;col-md-1&quot;&gt;Employee ID&lt;/th&gt;
       40 |                         &lt;th class=&quot;col-md-2&quot;&gt;First Name&lt;/th&gt;
       41 |                         &lt;th class=&quot;col-md-2&quot;&gt;Last Name&lt;/th&gt;
       42 |                         &lt;th class=&quot;col-md-7&quot;&gt;Benefits Start Date&lt;/th&gt;
       43 |                     &lt;/tr&gt;
       44 |                 &lt;/thead&gt;
       45 |                 &lt;tbody&gt;
       46 | 
       47 |                     {% for user in users %}
       48 | 
       49 |                     &lt;tr&gt;
       50 |                         &lt;td&gt;{{user._id.toString()}}&lt;/td&gt;
       51 |                         &lt;td&gt;{{user.firstName}}&lt;/td&gt;
       52 |                         &lt;td&gt;{{user.lastName}}&lt;/td&gt;
       53 |                         &lt;td&gt;
=&gt;     54 |                             &lt;form method=&quot;POST&quot; action=&quot;/benefits&quot;&gt;
       55 |                                 &lt;div class=&quot;input-group&quot;&gt;
       56 |                                     &lt;input type=&quot;hidden&quot; name=&quot;userId&quot; value=&quot;{{user._id.toString()}}&quot;&gt;&lt;/input&gt;
       57 |                                     &lt;input type=&quot;date&quot; class=&quot;form-control&quot; name=&quot;benefitStartDate&quot; value=&quot;{{user.benefitStartDate}}&quot;&gt;&lt;/input&gt;
       58 |                                     &lt;span class=&quot;input-group-btn&quot;&gt;
       59 |                                         &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Save&lt;/button&gt;
       60 |                                     &lt;/span&gt;
       61 |                                 &lt;/div&gt;
       62 |                                 &lt;!-- /input-group --&gt;
       63 |                             &lt;/form&gt;
       64 |                         &lt;/td&gt;
       65 |                     &lt;/tr&gt;
       66 |                     {% endfor %}
       67 |                 &lt;/tbody&gt;
       68 |             &lt;/table&gt;
       69 | 
       70 |         &lt;/div&gt;
       71 |         &lt;!-- /.row --&gt;
       72 |     &lt;/div&gt;
       73 | &lt;/div&gt;
       74 | </code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#370</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/login.html:107</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">python.django.security.django-no-csrf-token.django-no-csrf-token</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>```json
{
  &quot;rationale&quot;: &quot;The form is missing the Django CSRF token, making it vulnerable to Cross-Site Request Forgery (CSRF) attacks. An attacker could trick a logged-in user into submitting this form to an unauthorized location or with malicious data.&quot;,
  &quot;fix_suggestion&quot;: &quot;Add the `{% csrf_token %}` template tag within the form to automatically generate and include the CSRF token. This is the standard Django way to mitigate CSRF vulnerabilities.&quot;,
  &quot;patch&quot;: {
    &quot;before&quot;: &quot;&lt;form method=\&quot;post\&quot; role=\&quot;form\&quot; method=\&quot;post\&quot; id=\&quot;loginform\&quot;&gt;&quot;,
    &quot;after&quot;: &quot;&lt;form method=\&quot;post\&quot; role=\&quot;form\&quot; id=\&quot;loginform\&quot;&gt;\n                                {% csrf_token %}&quot;
  },
  &quot;references&quot;: [
    &quot;https://docs.djangoproject.com/en/stable/ref/csrf/&quot;
  ]
}
```</code></pre>
            <details class='ctx-details'><summary>View code context</summary><pre class='ctx-pre'><code>       87 |                             &lt;span style=&quot;font-size: x-large&quot;&gt;
       88 |                                 &lt;span class=&quot;fa fa-bullseye&quot;&gt;&lt;/span&gt;Retire&lt;b&gt;Easy&lt;/b&gt;
       89 |                             &lt;/span&gt;
       90 |                             &lt;br /&gt;
       91 |                             &lt;span style=&quot;font-size: medium&quot;&gt;Employee Retirement Savings Management&lt;/span&gt;
       92 |                             &lt;br /&gt;
       93 |                             &lt;br /&gt;
       94 |                         &lt;/div&gt;
       95 |                         &lt;div class=&quot;panel-body&quot;&gt;
       96 | 
       97 | 
       98 |                             {% if loginError %}
       99 |                             &lt;div class=&quot;alert alert-dismissable alert-danger&quot;&gt;
      100 |                                 &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;
      101 |                                 {{loginError}}
      102 |                             &lt;/div&gt;
      103 |                             {% endif %}
      104 | 
      105 | 
      106 | 
=&gt;    107 |                             &lt;form method=&quot;post&quot; role=&quot;form&quot; method=&quot;post&quot; id=&quot;loginform&quot;&gt;
      108 |                                 &lt;div class=&quot;form-group&quot;&gt;
      109 |                                     &lt;label for=&quot;userName&quot;&gt;User Name&lt;/label&gt;
      110 |                                     &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;userName&quot; name=&quot;userName&quot; value=&quot;{{userName}}&quot; placeholder=&quot;Enter User Name&quot;&gt;
      111 |                                 &lt;/div&gt;
      112 | 
      113 |                                 &lt;div class=&quot;form-group&quot;&gt;
      114 |                                     &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;
      115 |                                     &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;{{password}}&quot; placeholder=&quot;Enter Password&quot;&gt;
      116 |                                 &lt;/div&gt;
      117 |                                 &lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;{{csrftoken}}&quot; /&gt;
      118 | 
      119 |                                 &lt;div class=&quot;row&quot;&gt;
      120 |                                     &lt;div class=&quot;col-lg-4&quot;&gt;&lt;a href=&quot;/signup&quot;&gt;New user? Sign Up&lt;/a&gt;
      121 |                                     &lt;/div&gt;
      122 |                                     &lt;div class=&quot;col-lg-5&quot;&gt;&lt;/div&gt;
      123 |                                     &lt;div class=&quot;col-lg-3&quot;&gt;
      124 |                                         &lt;button type=&quot;submit&quot; class=&quot;btn btn-danger&quot;&gt;Submit&lt;/button&gt;
      125 |                                     &lt;/div&gt;
      126 |                                 &lt;/div&gt;
      127 |                             &lt;/form&gt;</code></pre></details>
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#371</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/memos.html:15</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">python.django.security.django-no-csrf-token.django-no-csrf-token</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Manually-created forms in django templates should specify a csrf_token to prevent CSRF attacks.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#372</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/tutorial/a2.html:207</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">html.security.plaintext-http-link.plaintext-http-link</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#373</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/tutorial/a2.html:209</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">html.security.plaintext-http-link.plaintext-http-link</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#374</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/tutorial/a2.html:210</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">html.security.plaintext-http-link.plaintext-http-link</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#375</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/tutorial/a5.html:50</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">html.security.plaintext-http-link.plaintext-http-link</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#376</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>app/views/tutorial/a5.html:51</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">html.security.plaintext-http-link.plaintext-http-link</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">This link points to a plaintext HTTP URL. Prefer an encrypted HTTPS URL if possible.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#377</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>artifacts/cert/server.key:1</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">generic.secrets.security.detected-private-key.detected-private-key</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Private Key detected. This is a sensitive credential and should not be hardcoded here. Instead, store this in a separate, private file.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#378</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>artifacts/db-reset.js:19</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">generic.secrets.security.detected-bcrypt-hash.detected-bcrypt-hash</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">bcrypt hash detected</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#379</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>artifacts/db-reset.js:28</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">generic.secrets.security.detected-bcrypt-hash.detected-bcrypt-hash</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">bcrypt hash detected</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-error"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#380</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-error">error</span>
            <span class="location"><code>artifacts/db-reset.js:36</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">generic.secrets.security.detected-bcrypt-hash.detected-bcrypt-hash</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">bcrypt hash detected</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#381</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>docker-compose.yml:13</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">yaml.docker-compose.security.no-new-privileges.no-new-privileges</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Service &#x27;mongo&#x27; allows for privilege escalation via setuid or setgid binaries. Add &#x27;no-new-privileges:true&#x27; in &#x27;security_opt&#x27; to prevent this.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#382</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>docker-compose.yml:13</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Service &#x27;mongo&#x27; is running with a writable root filesystem. This may allow malicious applications to download and run additional payloads, or modify container files. If an application inside a container has to save something temporarily consider using a tmpfs. Add &#x27;read_only: true&#x27; to this service to prevent this.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#383</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-default-name</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Donâ€™t use the default session cookie name Using the default session cookie name can open your app to attacks. The security issue posed is similar to X-Powered-By: a potential attacker can use it to fingerprint the server and target attacks accordingly.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#384</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-domain</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Default session middleware settings: `domain` not set. It indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested. If they match, then check the path attribute next.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#385</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-expires</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Default session middleware settings: `expires` not set. Use it to set expiration date for persistent cookies.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#386</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-httponly</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Default session middleware settings: `httpOnly` not set. It ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#387</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-path</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Default session middleware settings: `path` not set. It indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#388</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:78</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-secure</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Default session middleware settings: `secure` not set. It ensures the browser only sends the cookie over HTTPS.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      <div class="timeline-item" data-tool="semgrep">
        <div class="timeline-rail">
          <div class="timeline-dot sev-warning"></div>
          <div class="timeline-line"></div>
        </div>

        <article class="finding-card">
          <header class="finding-header">
            <span class="id-tag">#389</span>
            <span class="tool-badge">SEMGREP</span>
            <span class="sev-pill sev-warning">warning</span>
            <span class="location"><code>server.js:145</code></span>
          </header>

          <div class="finding-main">
            <div class="vuln">
              <div class="label">Vulnerability</div>
              <div class="text">problem-based-packs.insecure-transport.js-node.using-http-server.using-http-server</div>
            </div>
            <div class="desc">
              <div class="label">Original Description</div>
              <div class="text">Checks for any usage of http servers instead of https servers. Encourages the usage of https protocol instead of http, which does not have TLS and is therefore unencrypted. Using http can lead to man-in-the-middle attacks in which the attacker is able to read sensitive information.</div>
            </div>
          </div>

          <div class="finding-ai">
            <div class="label">AI Fix Suggestion &amp; Context</div>
            <pre class="ai-pre"><code>AI remediation skipped (quota saving).</code></pre>
            
          </div>
        </article>
      </div>
      
      </section>
    </div>
  </div>

<script>
  (function() {
    const buttons = document.querySelectorAll('.filter-btn');
    const items = document.querySelectorAll('.timeline-item');

    function applyFilter(filter) {
      items.forEach(item => {
        const tool = item.getAttribute('data-tool') || '';
        if (filter === 'all' || tool === filter) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
    }

    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        const filter = btn.getAttribute('data-filter-tool');
        buttons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        applyFilter(filter);
      });
    });
  })();
</script>
</body>
</html>

